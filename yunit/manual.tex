%--template 'shared_template.tex' --def title='Модульное тестирование'

\newcommand{\testunit}{testunit} % unit test library draft title

%-------------------------------------------------------------------------------------------------------------
\section{Модульные тесты}

Модульное тестирование (unit test) "--- это тестирование отдельных функций исходного кода программы или программного комплекса. Модульное тестирование является одним из видов тестирования, выполняемых в рамках обеспечения надежности разрабатываемого ПО.

%-----------------------------------------------------------------------------------------
\subsection{Особенности модульного тестирования}

С технической точки зрения модульное тестирование заключается в выполнении тестируемых функций на некотором множестве исходных данных и сверке получаемых результатов с заранее известными с целью установить соответствие функции ее спецификации.

Таким образом, элементарный тест (test case) представляет собой программу, осуществляющую:
\begin{enumerate}
\item подготовку исходных данных;
\item выполнение тестируемой функции;
\item сверку полученных результатов с ожидаемыми;
\item освобождение использованных ресурсов;
\item вывод результата проверки.
\end{enumerate}

Для написания тестов используется тот же язык, что и для написания тестируемого кода.

Программирование теста осуществляется в соответствии с образцами xUnit: проверка (Assertion), фикстура (Fixture), внешняя фикстура (External Fixture), тестовый метод (Test Method), тест исключительной ситуации (Exception Test). 

Для убедительной проверки соответствия функции ее спецификации требуется выполнить набор тестов (test suite), включающий набор логически связанных тестов. 

Минимальной единицей исходного кода, которая включается в состав программы, выполняющей тесты, является минимальная физическая единица исходного кода "--- компонент (component, группа файлов с одинаковым именем \path{name.*}), содержащая набор функций, возможно объединенных в классы, которые составляют законченную часть логического дизайна.

Тестирование компонентов выполняется в рамках программирования пакета (Package), объединяющего группу логически и физически связанных компонентов в атомарную единицу процесса сборки.

ПК, состоящие из множества компонентов, требуют специальных способов организации процессов модульного тестирования. Для упрощения тестов, уменьшения их числа, быстрой локализации ошибки и легкой отладки используется восходящее модульное тестирование. Оно выполняется программистами в процессе создания исходного кода и подразумевает последовательное автоматизированное тестирование зависимых компонентов начиная с нижних уровней.

%-----------------------------------------------------------------------------------------
\subsection{Зачем проводить тесты}

\begin{itemize}
\item Вы знаете, что система работает
\item Вы знаете, что работаете на стабильной программной платформе\footnote{Т.е. все компоненты, от которых зависит разрабатываемый вами код протестирован и соответствует своей спецификации}.
\item Вы знаете, что последние изменения (сделанные после последнего пройденного теста) не добавили в программу ошибок.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Результаты обратной связи от модульных тестов}

\begin{itemize}
\item У вас есть уверенность в том, что созданный фрагмент действительно работает.
\item Тесты дают разработчику <<страховочную сеть>>. Вы можете смело вносить изменения, в том числе большие по объему и достаточно рискованные. Если вы сделали ошибку, то узнаете об этом очень быстро.
\item Вы почти не используете программы отладки. Вы сразу же узнаете о том, что какая-то часть системы дает сбой, т.к. не сделали ничего после последнего удачного теста и точно знаете, какой именно тест не был пройден. Поэтому проблему можно обнаружить достаточно быстро.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Бонусы от использования модульных тестов}

\begin{itemize}
\item Ускорение разработки и повышение качества выпускаемого кода. За счет раннего тестирования исходного кода на уровне модулей уменьшается количество ошибок, проникающих на уровень приложения, т.е. снижается время на их выявление и отладку, что покрывает все расходы на написание модульных тестов.
\item Можно воспроизводить в тестах такие условия (контекст) вызова кода, который получить в реальных и тестовых условиях использования продукта очень трудно. Тем самым снижается число трудноуловимых ошибок.
\item Тесты являются документацией к коду, по ним видно как именно его нужно использовать. Такая документация не потеряет актуальности пока эти тесты выполняются успешно.
\item Тесты дают возможность комфортно проводить рефакторинг кода. Тесты проследят за тем, чтобы поведение улучшаемого кода осталось прежним.
\item stub- и mock-объекты позволяют производить независимую разработку зависимого и влияющего кода.
\item Тесты можно использовать при рецензировании кода, например, рецензент может добавлять полезные, на его взгляд, тесты, выявляющие проблемы в рецензируемом коде.
\item Тесты снижают цену ошибки. Если код тестируется на уровне модуля, особенно низкоуровневого, то объем кода тестов достаточно мал. Но если для того, чтобы протестировать код, вам приходится писать более высокоуровневый код, например, делающий доступ  к новой функциональности из графического интерфейса, то в случае возможной ошибки вам придется исправлять намного больший объем кода: и свой, и весь вспомогательный.
\item Поскольку тесты заставляют писать классы, которые можно протестировать отдельно, без привлечения стороннего кода (заменяя, например, его mock объектами), то код получается более структурированный и лучше спроектированный.
\item По поведению тестов можно отслеживать огрехи в архитектуре, например:
    \begin{itemize}
    \item если ваши тесты начинают ломаться в самых непредсказуемых местах, это означает, что одна часть разрабатываемого приложения непредсказуемым образом влияет на другую его часть;
    \item если ваш код начальной инициализации теста вгоняет в тоску своим объемом, это значит что ваши объекты слишком большие и их требуется разделить;
    \item если вы не можете быстро найти общее место для общего кода инициализации и у вас остается в нем дублирование, это означает что у вас слишком много объектов, которые слишком тесно взаимодействуют друг с другом.
    \end{itemize}
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Где модульные тесты <<не работают>>}

\begin{itemize}
\item Многопоточное и многопроцессное программирование;
\item Тестирование графического интерфейса \footnote{Поэтому приходится отделять бизнес-логику от интерфейса, чтобы ее протестировать};
\end{itemize}

Если прогон модульных тестов во время процесса разработки требует значительного времени (порог -- 10 сек), то программист будет запускать их недостаточно часто и практическая польза от тестов снизиться (возможно до нуля).

Если прогон регрессионные тестов будет выполняться дольше 10 мин, то ситуация будет аналогично предыдущей.

%-----------------------------------------------------------------------------------------
\subsection{Отрицательная сторона модульного тестирования}

\begin{itemize}
\item На написание тестов тратиться время.
\item Тесты -- это дополнительный код, который нужно сопровождать.
\item При изменении требований придется переделать не только прикладной код, но и тесты к нему.
\end{itemize}


%-----------------------------------------------------------------------------------------
\subsection{Полезные советы}

\begin{itemize}
\item Пишите тесты с максимально просто, чтобы отсутствие ошибки можно было проверить визуально. В противном случае нужно будет писать тесты для самих тестов, что порождает излишне сложную и непрактичную схему. Т.е. избегайте использования в тестах ветвлений кода, циклов и др. сложных конструкций, старайтесь, чтобы код теста был линейным.
\item Если вы обнаружили в коде ошибку, которая проявлялась при выполнении тестов, то перед тем как ее править, напишите тест, выявляющий эту ошибку. Теперь вы будете уверены, что в будущем она не всплывет вновь.
\item Старайтесь писать хорошие тесты. В противном случае вы получите чувство ложной уверенности в работоспособности вашего кода.
\item Применяя TDD вы <<впишете>> тесты в сам процесс разработки, вам не нужно будет насильно заставлять себя разрабатывать тесты, вы перестанете считать их бесполезным кодом, на который к тому же тратиться драгоценное время, отведенное на реализацию полезной функциональности.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Что за такое TDD}

TDD (Test Driven Development) переводиться как <<разработка через тестирование>>. А именно, сначала пишутся тесты, и только потом сам код, который они тестируют.

Вот так примерно выглядит процесс разработки по данной методике:
\begin{itemize}
\item Создаем новый тест. При его написании мы определяемся с тем, что именно хотим получить и как использовать. Можно назвать это этапом постановки требований к своему коду.
\item Убеждаемся, что он не компилируется.
\item Создаем код, реализующий вызываемые в тесте интерфейсы.
\item Убеждаемся, что тест компилируется, но тестовый драйвер не линкуется.
\item Создаем пустую (fake) реализацию.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется, но валиться при выполнении.
\item Создаем нормальную реализацию кода.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется и успешно выполняется.
\item Проводим рефакторинг прикладного кода.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется и успешно выполняется.
\item Запускаем регрессионные тесты, убеждаемся, что они все проходят.
\item Сдаем код в репозиторий.
\end{itemize}

Если вы имеете достаточно опыта в TDD, то вы можете решить для себя, что приемлемо пропускать некоторые промежуточные шаги, можете работать сразу над несколькими тестами и т.д.

Что хорошего в TDD, так это то, что решение большой задачи разбивается на последовательность мелких обозримых шажков, позволяющих думать в один момент времени только над одной частью общей задачи и не держать в голове несколько аспектов сразу.

\clearpage

%-------------------------------------------------------------------------------------------------------------
\section{Библиотека модульных тестов \testunit}

Рабочее название -- \testunit. Предлагаемое: YUnit.
Она упрощает программирование и выполнение модульных тестов, поддерживая процесс экстремального программирования.

%-----------------------------------------------------------------------------------------
\subsection{Список терминов и сокращений}

\begin{tabulary}{\textwidth}{p{\textwidth}}
{\bfseries <<Движок>>/библиотека модульных тестов (Test Unit Engine)} -- вся библиотека \testunit\ как отдельный пакет \\
{\bfseries Контейнер тестов (Test Container)} -- файлы, содержащие набор тестов в некотором формате (\path{*.t.dll}, бинарный формат в случае тестов на C++ (C++ Test Container) и \path{*.t.lua}, текстовый формат в случае тестов на Lua (Lua Test Container)\\
{\bfseries Тестовый драйвер (Test Driver)} -- это контейнер тестов и сценарий запуска содержащихся в нем тестов \\
{\bfseries <<Запускалка>> тестов (Test Runner)} --  та часть функциональности библиотеки \testunit, которая отвечает за поиск, загрузку тестовых контейнеров, получение из них списков тестов, их запуск и публикация результатов прогона тестов \\
{\bfseries <<Движок>> тестов для определенного языка программирования (Programming Language Test Engine)} -- та часть функциональности библиотеки \testunit, которая отвечает за синтаксис тестов, набор тестовых проверок, составление коллекции тестов в Test Container-е и защищенный вызов тестовых функций для тестов, написанных на определенном языке программирования. На данный момент реализованы два таких <<движка>>: C++ Test Engine и Lua Test Engine \\
{\bfseries } Тест кейс (контрольный пример) (Test Case) -- один отдельный тест \\
{\bfseries } Набор тестов (Test Suite) -- набор тест кейсов \\
\end{tabulary}

%-----------------------------------------------------------------------------------------
\subsection{Quick Start}

Chapter content has been moved to Wiki: \url{http://code.google.com/p/yunit/wiki/QuickStartGuide}

%-----------------------------------------------------------------------------------------
\subsection{Синтаксис}

%---------------------------------------------------------------------
\subsubsection{C++ Test Engine}

Chapter content has been moved to Wiki: \url{http://code.google.com/p/yunit/wiki/CppUnitTestSyntax}

%---------------------------------------------------------------------
\subsubsection{Lua Test Engine}

Chapter content has been moved to Wiki: \url{http://code.google.com/p/yunit/wiki/LuaUnitTestSyntax}

%-----------------------------------------------------------------------------------------
% \subsection{Процесс разработки}

%-----------------------------------------------------------------------------------------
% \subsection{Создание тестового модуля в Visual Studio 2010}

%-----------------------------------------------------------------------------------------
\subsection{Запуск тестов}
\label{sec:run_test_properties}

Для запуска тестов одного тестового контейнера можно использовать отдельный модуль \path{default_test_run.lua}. Командная строка запуска будет выглядеть примерно так:
\begin{verbatim}
lua5.1.exe -l testunit.load_scite_listener -l testunit.default_test_run
 -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

Вместо непосредственного указания пути к файлу контейнера ~(TEST\_CONTAINER\_PATH) можно указывать:
\begin{itemize}
\item SciTE: \verb`$(FileNameExt)`
\item Visual Studio 2010: \verb`$(TargetPath)`
\end{itemize}

В качестве скрипта загрузки TestListner можно указывать:
\begin{itemize}
\item SciTE: \verb`testunit.load_vs_listener`
\item Visual Studio 2010: \verb`testunit.load_scite_listener`
\end{itemize}

Указывать \verb`TEST_CONTAINER_PATH` в двойных квадратных скобках необходимо, чтобы корректно обработать в пути обратные слэши (backslash).
Если \testunit\ установлен в нестандартной папке и приложение-интерпретатор не может самостоятельно найти этот модуль, придется добавить в командную строку перед ключом \verb`-l` дополнительный код:
\begin{verbatim}
lua5.1.exe 
-e "package.path=[[PATH_TO_TESTUNIT/?.lua]]..package.path"
-l testunit.load_scite_listener -l testunit.default_test_run
-e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

В SciTE составленную командную строку можно задать, например, в настройках пользователя, прописав:
\begin{verbatim}
command.go.*.t.lua=lua5.1.exe 
-l testunit.load_scite_listener -l testunit.default_test_run -e "run([[$(FileNameExt)]])"
\end{verbatim}

В Visual Studio 2010 нужно добавить ее в настройки проектника, например:
\begin{itemize}
\item Debugging $\to$ Command = \path{lua5.1.exe}
\item Debugging $\to$ Command Arguments = \\
\verb`-l testunit.load_vs_listener -l testunit.default_test_run -e "[[$(TargetPath)]]"`
\item Build Events $\to$ Post-Build Event $\to$ Command Line = \\
\verb`lua5.1.exe -l testunit.load_vs_listener -l testunit.default_test_run`\\
\verb` -e "[[$(TargetPath)]]"`
\item Build Events $\to$ Post-Build Event $\to$ Description = Run unit tests \ldots
\end{itemize}

%-------------------------------------------------------------------------
\subsection{Доставка изменений в центральный репозиторий}

Если делаете доставку пакета, то прогоните перед этим все его модульные тесты, если группу пакетов -- тесты всех пакетов, входящих в эту группу. Количество запускаемых тестов может быть сознательно ограничено с расчетом, что их выполнение не задержит надолго доставку, с другой стороны -- даст минимальную уверенность в том, что внесенные изменения не <<сломают>> всю систему.

%-------------------------------------------------------------------------
\subsection{<<Night Build>>}

Сервером непрерывно интергарции (Continuous Intergation Server) выполняется сборка и модульное тестирование значительного количества компонентов (например, всех), находящихся в хранилище исходного кода. Можно подобную операцию выполнять дважды в сутки:
\begin{itemize}
\item в обед (чтобы успеть до ухода домой поправить выявленные ошибки);
\item ночью (чтобы с утра <<порадоваться>> сделанным вчера вечером ошибкам).
\end{itemize}

Джоэл Спольски рекомендует в качестве наказания виновного за проваленную сборку назначать того ответственным за подобные полные сборки до тех пор, пока не облажается кто-нибудь еще.

%-------------------------------------------------------------------------------------------------------------
\section{Рекомендуемая литература}

\begin{enumerate}
\item Кент Бек <<Экстремальное программирование: разработка через тестирование>>
\item Кент Бек, Мартин Фаулер <<Экстремальное программирование: планирование>>
\item Мартин Фаулер <<Рефакторинг. Улучшение существующего кода>>
\item Джерард Месарош <<Шаблоны тестирования xUnit. Рефакторинг кода тестов>>
\end{enumerate}