%--template 'shared_template.tex' --def title='Модульное тестирование' --def author='\we' --def today='???'
\newcommand{\framed}[1]{\fbox{\parbox{\textwidth}{#1}}}
\newcommand{\reason}[1]{\footnote{\framed{\textbf{Причина:}\\ #1}}}
\newcommand{\divblock}[1]{$ $\\}
\newcommand{\yunit}{yunit}

\newcounter{faqCount}
\setcounter{faqCount}{0}
\newcommand{\FAQbegin}{}
\newcommand{\FAQend}{\medskip\hrule}
\newcommand{\fastQ}{\addtocounter{faqCount}{1}\medskip\hrule\medskip{\red Q\arabic{faqCount}?}\quad}
\newcommand{\fastA}{{\blue A:}\quad}

%-------------------------------------------------------------------------------------------------------------
\section{Список терминов и сокращений}

\begin{tabulary}{\textwidth}{p{\textwidth}}
{\bfseries <<Движок>>/библиотека модульных тестов (Test Unit Engine)} -- вся библиотека yunit как отдельный пакет \\
{\bfseries Контейнер тестов (Test Container)} -- файлы, содержащие набор тестов в некотором формате (\path{*.t.dll}, бинарный формат в случае тестов на C++ (C++ Test Container) и \path{*.t.lua}, текстовый формат в случае тестов на Lua (Lua Test Container)\\
{\bfseries Тестовый драйвер (Test Driver)} -- это набор тестов и сценарий запуска для содержащихся в них тестов \\
{\bfseries <<Запускалка>> тестов (Test Runner)} --  та часть функциональности библиотеки yunit, которая отвечает за поиск, загрузку тестовых контейнеров, получение из них списков тестов, их запуск и публикация результатов прогона тестов \\
{\bfseries <<Движок>> тестов для определенного языка программирования (Programming Language Test Engine)} -- та часть функциональности библиотеки yunit, которая отвечает за синтаксис тестов, набор тестовых проверок, составление коллекции тестов в Test Container-е и защищенный вызов тестовых функций для тестов, написанных на определенном языке программирования. На данный момент реализованы два таких <<движка>>: C++ Test Engine и Lua Test Engine \\
{\bfseries } Тест кейс (контрольный пример) (Test Case) -- один отдельный тест \\
{\bfseries } Набор тестов (Test Suite) -- набор тест кейсов \\
\end{tabulary}

Есть требования, которым должен отвечать библиотека для работы с модульными тестами:
\begin{itemize}
\item Нужно уметь прогонять тесты для приложений на любом из используемых нами языков; 
\item Нужно уметь определять состав имеющихся тестов;
\item Нужно уметь запускать из всех тестов только определенные их наборы. Набор (коллекция) тестов может состоять как из одного теста, так и из всех тестов сразу;
\item Нужно уметь производить эти запуски удаленно, в несколько параллельных запусков (от разных пользователей), с ведением централизованных логов, с сохранением результатов в централизованную базу знаний\footnote{для последующего анализа менеджером проекта} и т.п.
\item Нужно уметь "<публиковать"> результаты тестов на обозрение разработчиков;
\item Нужно уметь прогонять тесты не только для наших проектов, но и для внешних\footnote{Конечно, обвешивание тестами готового проекта чрезвычайно сложно, но иногда может и понадобиться};
\item Нужно стремиться к минимизации времени реакции на запуск тестов. Весь прогон тестов должен быть настолько быстрым, что его было бы комфортно запускать разработчику как можно чаще;
\item Нужно уметь запускать всякие "<NightBuild">-ы полностью в автоматическом режиме, по расписанию и т.д.
\item Нужно уметь интегрировать управление запуском тестов в используемые IDE.
\end{itemize}

Кроме читабельных сообщений в output-е необходимы данные, на которые мог бы опираться скрипт выполняемый без участия человека. Т.е. в результате прогона теста скрипт должен знать о количестве успешных и количестве провалившихся тестов, их имена и сообщения об ошибках. Крах одного из тестом может означать остановку компиляции и запуска тестов всех пакетов, зависящих от того, чей тест грохнулся\footnote{Выяснение зависимостей между пакетами -- это другая задачка, просто смежная, в "<Large Scale">, в приложении С должно быть краткое описание этого процесса}. 

%-------------------------------------------------------------------------------------------------------------
\section{Требования к библиотеке}

При проектировании решения надо отталкиваться от следующих предпосылок:
\begin{itemize}
\item Движок для запуска тестов нужно писать на Lua\reason{Цель -- это автоматизированный процесс восходящего регрессионного тестирования всего кода, который мы успели (и еще успеем) наколотить. Причем выставленного интерфейса должно хватать на реализацию веб-интерефейса, позволяющего разработчику несколькими щелчками мыши запускать тестовые модули только что доставленного пакета};
\item Пока при разработке из языков программирования мы будем использовать Lua и C/C++;
\item Придется уметь работать с такими IDE как MS Visual Studio и SciTE;
\item Всякие удаленные сборки будут запускаться с использованием сервера непрерывной интеграции;
\item Переносимость приветствуется;
\end{itemize}

%-------------------------------------------------------------------------------------------------------------
\section{Анализ предметной области}

Выделим семейство процессов разработки с использованием модульных тестов:
\begin{itemize}
\item разработка прикладного кода на C++ 
\item разработка прикладных кода на Lua
\item разработка кода С++, выставленного в Lua, и тесты на Lua к нему (гетерогенная разработка)
\end{itemize}

Общими для семейства являются:
\begin{itemize}
\item работаем в среде разработки
\item пишем тесты на языке разработки
\item запускаем тесты на выполнение
\end{itemize}

Разработка в стиле TDD или без него -- не важно, это положительная изменчивость.

Отрицательная изменчивость -- запуск тестов при помощи Hudson, он не разрабатывает, а только запускает тесты (прогон вне среды).

Использование генератора кода (либо чего-то другого) для создания оберток в Lua считаем выходящим за рамки данного анализа, и вообще плохим вариантом.

Разработка скриптов на Lua в рамках и для ГеПарта также выходит за рамки данного семейства, т.е. из разработчиков остаемся только мы, заказчики -- нет.

Для написания тестов используется тот же язык, что и для написания тестируемого кода.

% \newcommand{\question}[1]{\fbox{\parbox{0.05\textwidth}{\huge\textbf{?}}}\fbox{\parbox{0.9\textwidth}{\quad #1}}}

% \newcommand{\question}[1]{%
%     \begin{tabular}{|c|c|}
%     \hline
%     &\\
%     \parbox[c][\totalheight][c]{1em}{\Huge\textbf{?}}&\parbox{.85\textwidth}{#1}\\
%     &\\
%     \hline
%     \end{tabular}
% }%

\pagebreak
%-------------------------------------------------------------------------------------------------------------
\section{Особенности реализации}

%-----------------------------------------------------------------------------------------
\subsection{Рабочая копия}

%-----------------------------------------------------
\subsubsection{Cхема расположения файлов в рабочей копии}

\begin{figure}[htbp]
\centering
\psset{mcol=l,rowsep=0.5ex,colsep=0em,nodesep=5pt,arm=0.5em,angleA=270,angleB=180}
\begin{psmatrix}
& \path{..}   \\ 
& \path{_bin} \\
& & \path{lua5.1.exe} \\
& & \path{lua5.1.dll} \\
& & \path{cppunit.dll} \\
& & \path{package1.dll} \\
& & \path{package1.t.dll} \\
& \path{_lib} \\
& & \path{lua5.1.lib} \\
& & \path{package2.lib} \\
& \path{yunit}    \\
& & \path{test_runner.lua}  \\
& & \path{test_listeners.lua}  \\
& & \path{test.h}           \\
& \path{lua}   \\
& & \path{lua.h}      \\
& & \path{lualib.h}      \\
& & \path{luaxlib.h}      \\
& \path{package1}   \\
& & \path{_misc}      \\
& & & \path{*.sqlite}      \\
& & & \path{*.txt}      \\
& & \path{*.h}      \\
& & \path{*.cpp}    \\
& & \path{*.t.cpp}  \\
& & \path{*.lua}    \\
& & \path{*.t.lua}  \\
\ncangle{2,2}{3,3}
\ncangle{4,2}{5,3} \ncangle{4,2}{6,3} \ncangle{4,2}{7,3} \ncangle{4,2}{8,3} \ncangle{4,2}{9,3}
\end{psmatrix}
\caption{Схема рабочей копии} \label{fig:tests_at_working_copy}
\end{figure}

Причины подобной схемы расположения файлов можно узнать в главе <<Рабочее пространство>> документа <<Руководства программиста>>. К описанию из этой главы можно добавить некоторые подробности, касающиеся тестов:
\begin{itemize}
\item Файлы скриптов Lua (\path{*.lua}) и тестов к ним \path{*.t.lua} располагаются внутри пакетов\reason{Они являются файлами исходного кода, а не бинарниками, которым для запуска могут понадобиться внешние библиотеки и проще, если они будут лежать рядом}.
\item Пакет \path{yunit} обязателен для использования модульных тестов.
\item Иногда для тестов нужны вспомогательные файлы (БД, бинарные и текстовые файлы, образы виртуальных машин и пр.), они лежат в отдельной подпапке пакета с именем \path{_misc}. Их наличие или отсутствие -- лично дело разработчика пакета.
\item "<Плюсовый"> тестовый драйвер собирается в динамически загружаемую библиотеку \path{*.t.dll} или \path{*.t.so} в папку \path{_bin}.
\item Для сборки Test Container и запуска тестов используются библиотека и интерпретатор Lua, находящиеся в рабочей копии\reason{Это делает среду рабочей копии еще более независимой от среды операционной системы и установленных в ней компонентов}.
\end{itemize}

По идее сколько нужно программисту тестовых драйверов в одном пакете -- пусть столько и делает. Тут не нужно вводить ограничения.


%---------------------------------------------------------------------
\subsubsection{Приемы работы}

\fastQ Сейчас за счет использования заголовочных файлов "<плюсовые"> пакеты могут находить друг друга в пределах одной рабочей копии, можно создавать локальные тестовые среды. По идее той же схемы хотелось бы придерживаться и для "<луновых"> модулей, чем они собственно хуже?

\fastA Если действовать по аналогии с "<плюсовыми"> пакетами, то придется в require указывать и имя пакета, к которому относится нужный модуль. Это дает возможность сделать нормальную песочницу для разработки, к-ой безразлично, что установлено в системе. Кстати можно довести эту схему до абсолюта и интерпретатор Lua тоже собирать и использовать тот, что в песочнице, а не в системе.
Например, так работает (из-за особенностей паттерна пути в require не получится указать директорию "<..">):
\begin{lstlisting}[language=lua]
package.path="../?.lua;"..package.path
local fs = require("svn_wv_lua_scripts/filesystem");
print(fs.whatOs());
\end{lstlisting}

Нерешенным вопросом остается каким-то образом находить и запускать все тесты пакета/группы пакетов.

%-----------------------------------------------------
\subsection{Составные части}

Библиотека модульных тестов состоит из трех основных частей:
\begin{itemize}
\item <<плюсовый>> движок модульных тестов;
\item <<луновый>> движок модульных тестов;
\item <<запускалка>> тестов.
\end{itemize}

C++ Test Engine и Lua Test Engine аналогичны по архитектуре, но написаны на разных языках. Они содержат ту функциональность, которую не получиться вынести в Test Runner по причине языковых особенностей:
\begin{itemize}
\item механизм сбора тестов;
\item макросы проверки, обеспечивающие самопроверяемость тестов, они уникальны для каждого языка из-за типов данных переменных, проходящих проверку;
\item реализация синтаксиса написания тестов;
\item реализация защищенного вызова функции, что не позволяет одному заваленному тесту повалить весь процесс прогона тестов.
\item загрузка тестового контейнера\footnote{\path{*.t.dll} или \path{*.t.so} -- для C++ Test Engine, \path{*.t.lua} -- для Lua Test Engine}
\end{itemize}

%-----------------------------------------------------
\subsection{Основные классы}

\begin{itemize}
\item Test -- абстрактный базовый класс тестов, содержит виртуальную фукнцию test()
\item TestFixture -- базовый класс, содержит виртуальные фукнции setUp() и tearDown()
\item TestCase -- базовый класс тестов, производный от Test и TestFixture содержит пустые setUp() и tearDown(). Чтобы в тесте иметь возможность использовать некоторые разделяемые ресурсы, то необходимо сначала создать "<живую"> TestFixture и унаследовать от нее конкретный класс TestCase-а.
\item TestSuite -- набор тестов, содержит список TestCase-ов
\item TestRegistry -- реестр тестов
\end{itemize}

Перечисленные сущности имеются во всех частях библиотеки, реализуемые на разных языках.
А следующие объекты используются только в <<запускалке>>:
\begin{itemize}
\item TestResultHandlerList -- объект, получающий сообщения по ходу выполнения тестов и рассылающий их всем подписавшимся TestResultHandler-ам;
\item TestResultHandler -- выводит сообщения о тестах туда, где их будет смотреть разработчик;
\item TextTestProgressHandler -- выводит сообщения о тестах в output в виде простого текста.
\end{itemize}

Принадлежность TestCase-а к какому-либо TestSuite-у отражается пока только в названии, т.к. это самый простой способ. Если в общем реестре тестов начать делать иерархии, то это должно быть оправдано, можно опять к этому вернуться, когда более подробно будут проработаны требуемые критерии фильтрации списка выполняемые тестов.

%-----------------------------------------------------
\subsection{Механизм сбора тестов}

Этот механизм включает в себя создание объектов TestCase и их регистрация в реестре тестов.

\paragraph{в cppunit}

В C++ Test Engine сбор Test Case-ов из всех его тестовых контейнеров производится за счет создания глобальных объектов классов-регистраторов в момент загрузки, они создают в своих конструкторах статические объекты конкретных классов, производных от Test Case, и регистрируют их в общем реестре "<плюсовых"> тестов (Test Registry). Это накладывает ограничение, связанное с тем, что cppunit должен быть собран в виде DLL и ее в таком виде должны использовать тестовые контейнеры при своей сборке, тогда у всех загруженных тестовых контейнеров будет единое адресное пространство.

При таком способе управлять составом тестов, загружаемых из тестового контейнера, можно управлять только на этапе компиляции, включая/исключая файлы/код тестов из компиляции. 

Test Suite-ы создаются неявно при добавлении объектов Test Case: если уже есть Test Suite с именем, равным пути к cpp-файлу, где определен Test Case, то тест добавляется в него, иначе сначала создается новый Test Suite.

\paragraph{в luaunit}

Lua Test Engine исполняет каждый свой файл с тестами в подобии <<песочницы>> (sandbox), получая после этого таблицу, заполненную тестовыми функциями и фикстурами, определенными в данном файле. Он по ним проходит, преобразует в объекты типа Test Case и регистрирует в <<луновом>> Test Registry. Логика создания Test Suite та же, что и в cppunit.

%-----------------------------------------------------
\subsection{<<Запускалка>> тестов}

Одна из главных задач test\_runner-а -- это при помощи выставленных в Lua функций LTUE загрузить тестовые контейнеры и получить от них "<луновые"> объекты с интерфейсом TestCase-а:

\begin{tabulary}{\textwidth}{|l|}
\hline setUp() \\
test() \\
tearDown() \\ \hline 
name\_ \\
isIgnored\_ \\
fileName\_ \\
lineNumber\_ \\
\hline
\end{tabulary}

Затем все неигнорируемые тесты проходят <<рамку теста>>. Каждый тестовый контейнер загружается лишь единожды. Тестовый контейнер является минимальной единицей загрузки тестов, загрузка и запуск отдельных тестов, на мой взгляд, вещь бесполезная.

<<Рамка теста>> представляет из себя последовательный вызов функций \verb|setUp()|, \verb|test()| и \verb|tearDown()|, плюс в нужные моменты TestResultHandlerList-у посылаются сообщения о тестах (какой тест начал выполняться, как завершился, какой завершился и т.п.). Функция \verb|test()| не будет вызвана, если завершилась с ошибкой \verb|setUp()|. Если все-таки \verb|setUp()| выполнилась успешно, но будет вызвана \verb|test()| и обязательно -- \verb|tearDown()|. С помощью функций \verb|setUp()| и \verb|tearDown()| Вы можете инициализировать тестовую среду до выполнения теста и привести систему в исходное состояние после выполнения теста, чтобы не  мешать выполнению других тестов. Этим достигается независимость тестов относительно друг друга.

По сути Test Runner представляет собой функцию main, которую вынесли из тестовых драйверов, сделав их пассивными тестовыми контейнерами. Получилось, что для всех языков она одна. Это позволяет запустить десятки и более тестов и получить по ним СУММАРНУЮ статистику, можно на этапе выполнения регулировать список запускаемых тестов.

Поскольку у него объем кода немаленький, написан он на Lua, за счет этого удалось сократить затраты на разработку и сопровождение. Ярким примером является добавление новый TestResultHandler-ов, которые могут быть достаточно нетривиальными. Их может понадобиться несколько типов, например, выдающих полученные сообщения в определенном формате (txt, html, http-запрос) и на определенный приемник (консольный вывод, файл, syslogd, веб-сервер, Jabber Client). 

Сам Test Runner не знает какими Language Test Unit Engine-ами будет пользоваться. Этот список при помощи вызова дополнительного инициализирующего скрипта. Такая слабая связь позволяет свободно расширять список LTUE (добавляя, например, возможность писать тесты на ANSI C, SQL, Python и т.д.\footnote{Cами языки наверняка имеют C API, нужно просто используя его написать и выставить в Lua интерфейс LTUE}) и использовать только необходимые в разных сценариях использования.

Получается Test Runner замыкает цепочку препроцессор/компилятор/компоновщик в лице прогонщика тестов.

%-----------------------------------------------------------------------------------------
\subsection{Language Test Unit Engine}

Имеет следующий интерфейс\footnote{Больше пока ничего выставлять не надо, получается обходиться этим}, выставленный в Lua:
\begin{table}
\caption{}\label{tab:test_container_iface}
\begin{tabulary}{\textwidth}{|l|}
\hline
loadTestContainer(filepath) \\
getTestContainerExtensions() \\
getTestList() \\
\hline \\
$ $ \\
\hline
\end{tabulary}
\end{table}

\begin{itemize}
\item loadTestContainer -- загружает тестовый контейнер и регистрирует его тесты в реестре LTUE
\item getTestContainerExtensions -- возвращает список расширений файлов тестовых контейнеров, которые  относятся к данному LTUE
\item getTestList -- возвращает список <<луновых>> объектов TestCase
\end{itemize}

Когда у нас хостовым приложением является не сам Lua интерпретатор, а какое-нибудь из разрабатываемых нами приложений, то можно реализовать ту среду, в которой должны выполняться скрипты/тесты\footnote{скорее всего, в нашем хостовом приложении будет жестко ограничен набор используемых модулей, урезаны даже стандартные библиотеки и т.п.} за счет создания отдельного LTUE, который будет, используя разрабатываемые библиотеки, загружать тестовые контейнеры в специализированные <<песочницах>>.


%-----------------------------------------------------
\subsection{Прогон тестов}

Для запуска тестов одного тестового контейнера можно использовать отдельный модуль \path{default_test_run.lua}. Командная строка запуска будет выглядеть примерно так:
\begin{verbatim}
lua5.1.exe -l LOAD_RESULT_HANDLERS -l yunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}
Вместо LOAD\_RESULT\_HANDLERS можно использовать:
\begin{itemize}
\item SciTE: \verb`yunit.work_in_scite`
\item Visual Studio 2010: \verb`yunit.work_in_vs`
\end{itemize}
Вместо непосредственного указания пути к файлу контейнера (TEST~\_CONTAINER~\_PATH) можно указывать:
\begin{itemize}
\item SciTE: \verb`$(FileNameExt)`
\item Visual Studio 2010: \verb`$(TargetPath)`
\end{itemize}
Указывать \verb`TEST_CONTAINER_PATH` в двойный квадратных скобках необходимо, чтобы корректно обработать в пути обратные слэши (backslash).
Если yunit установлен в нестандартной папке и приложение-интерпретатор не может самостоятельно найти этот модуль, придется добавить в командную строку перед ключом \verb`-l` дополнительный код:
\begin{verbatim}
lua5.1.exe 
-e "package.path=[[PATH_TO_YUNIT/?.lua]]..package.path"
-l yunit.work_in_vs
-l yunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

Запуск большого количества тестов (всего пакета, группы пакетов и т.д.) выполняется не разработчиком, а сервером непрерывной интеграции\footnote{Он пока не проработан}.

%-----------------------------------------------------
\subsection{Синтаксис модульных тестов}

Функции-assert и выражения для объявления тестов на C++ реализованы с использованием макросов только потому, что необходимо использовать макросы \verb`__FILE__` и \verb`__LINE__` для составления сообщения об ошибке в тесте, используя которое IDE сможет нас перенаправить на <<завалившийся>> assert. При использовании же функций, увидеть какой именно assert завалился можно только по CallStack-у, что противоречит принципу TDD о неиспользовании отладчика при разработке.

Синтаксис тестов на C++ получился таким потому, что:
\begin{itemize}
\item Макросы решили именовать также как переменные и функции для удобства ввода.
\item Пришлось переименовать функции класса TestCase: setUp, test и tearDown, - в innerSetUp, execute и innerTearDown соответственно потому, что они начали совпадать по именам с макросами и препроцессор пытался в коде вместо имени фукнции подставить содержимое макроса.
\item Возможность оставлять код ignore-тестов\footnote{невыполняемых} некомпилируемым удалось добиться за счет того, что этот код попадает в тело fake-овой шаблонной функции, которая не компилируется как неиспользуемая, реальная же функция execute определяется с пустым телом.
\item Теперь тело теста явно ограничено фигурными скобками, чтобы IDE правильно могло делать автоматический отступ от начала строки.
\item Макрос определения ignore-теста отличается от обычного только подчеркиванием в начале имени, т.к. это коротко, визуально различимо, можно использовать в заменах регулярными выражениями.
\item Макросы для задания тестов, использующих разное количество TestFixture, имеют разные имена, потому что в C++ нельзя перегружать макросы.
\item Отсутствует явное задание Test Suite-ов для упрощения синтаксиса тестов
\end{itemize}

Синтаксис тестов на Lua опирается на следующие принципы:
\begin{itemize}
\item Не нужно писать require для модуля, реализующего синтаксис;
\item Не нужно объявлять контейнер с тестами отдельным модулем при помощи функции module;
\item Все функции, кроме объявленных как локальные\footnote{Например, \lua{local function someFunc() end}}, рассматриваются как тесты\reason{В этом случае отпадает необходимость следить за названиями функций, выделяя в них зарезервированные слова};
\item Если имя теста начинается с символа подчеркивания (\_), то тест считается проигнорированным;
\item Фикстура объявляется как нелокальная таблица с двумя обязательными полями -- функциями setUp и tearDown4
\item Для того, чтобы тест использовал определенную фикстуру, нужно объявить его элементом данной фикстуры типа <<function>>, в примере тест addTest использует sampleFixture;
\item Отсутствует явное задание Test Suite-ов для упрощения синтаксиса тестов. Все тесты тестового контейнера попадут в один TestSuite с именем, равным пути к файлу контейнера.
\end{itemize}

%-----------------------------------------------------
\subsection{Неразрешенные вопросы}

\FAQbegin

\fastQ Схема фильтрации запускаемых тестов пока не продумана. 

\fastA Основная мысль в том, чтобы выставлять флаги разрешения выполнения в реестре тестов самого test\_runner-а. Однако, надо отметить, что поскольку тесты содержаться в файлах ("<луновые"> в \path{*.t.lua}, "<плюсовые"> в \path{*.t.dll}), то фильтрацией списка запускаемых тестов можно управлять на двух уровнях: физическом (файлами), логическом (списками уже загруженный тестов).


\fastQ Первоначально задумывалось оставить возможность запускать чисто "<плюсовые"> тесты, используя лишь "<плюсовый"> код, и аналогично для "<луновой"> части. Имеет ли смысл это реализовать?

\fastA \ldots


\fastQ А если мы загружаем тестовые модули, собранные для разных версий cppunit, у к-ых одинаковые интерфейсные функции?

\fastA Главное - это чтобы не менялся интерфейс и поведение класса TestCase, а остальное не важно. А если будут отличаться, то мы упадем и все ("<мертвые программы не лгут">). Хотя могут быть сложности с выявлением ошибки подобного типа.

\FAQend

%-----------------------------------------------------------------------------------------
\subsection{w05147 Сделать ledaunit}
% \todo Переделать на пакете MetaUML
\begin{enumerate}[]
\item Факт: OLEDB выставлено в Leda, а не в Lua
\item $\to$ Факт: скрипты в chimera должны выполняться в заданном нами окружении (a'la sandbox)
\item $\to$ $\to$ В скриптах chimera нельзя использовать require
\item $\to$ $\to$ $\to$ =: ledaunit сам будет загружать модули chimera, например, oledb.
\item $\to$ $\to$ $\to$ =: ledaunit будет находиться в репозитории chimera из-за своей специализации
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: для загрузки тестовых контейнеров cppunit-а используется платформозависимая функция package.loadlib
\item Факт: для загрузки тестовых контейнеров luaunit-а специально подготавливается область видимости
\item $\to$ Предположение: процедура загрузки тестовых контейнеров может быть нетривиальной
\item \ldots
\item $\to$ тестовые контейнеры не являются полноценными модулями Lua и не должны грузиться функцией require
\item $\to$ $\to$ =: LTUE сами производят загрузку своих тестовых контейнеров
\item $\to$ $\to$ =: тестовые контейнеры не являются полноценными скриптами/модулями/библиотеками
\item $\to$ $\to$ $\to$ =: Test Runner не знает сколько и какие тесты содержатся в тестовых контейнерах

% \item Факт: LTUE часть структуры \yunit
% \item Факт: тестовых контейнеров много больше, чем LTUE 
% \item =: тестовые контейнеры не несут функциональности, расширяющие \yunit
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: модули Lua могут быть как бинарными, так и текстовыми
\item Факт: Lua грузит модули однотипно командой require
\item LTUE представляют из себя модули Lua
\item $\to$ =: LTUE должны нормально грузиться командой require
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: модульные тесты пишутся на том же языке, что и прикладной код
\item Предположение: в рамках этого языка создаются классы (если класс поддерживает ООП) и объекты, олицетворяющие тесты
\item $\to$ =: каждый LTUE при загрузке тестов из тестового контейнера формирует локальный реестр тестов в рамках своего языка
\item \quad Факт: Test Runner-у нужны объекты в его Lua VM, чтобы запускать тесты
\item $\to$ $\to$ =: LTUE должны дать Test Runner-у <<ниточки>> управления тестами (binding), которые они собрали из тестовых контейнеров
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Предположение: возможно нужно будет написать Test Runner на другом языке (м.б. и скриптовом, м.б. и нет)
\item Предположение: каждый LTUE должен иметь реализацию на своем языке и binding-и в языки, использованные при написании Test Runner-а(ов)
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: при разработке во время сборки проекта с тестами для их прогона Test Runner вызывается через командную строку 
\item Факт: при выполнении автоматических сборок проекта тесты будет выполнять Continuous Integration Server
\item Факт: для Hudson/Jenkins CI Server может быть написан plugin на Java для прогона тестов
\item Предположение: одновременно может использоваться несколько Test Runner-ов, написанных на разных языках программирования
\item Предположение: LTUE придется выставляться во все языки, использованные при создании Test Runner-ов
\item Предположение: Test Result Handler придется переписать на языке, использованном при создании Test Runner
\item \end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт$\ominus$: сейчас Test Runner сам знает о имеющихся LTUE, чтобы добавить/удалить хоть один необходимо изменить исходный код Test Runner-а
\item Предположение: нужно, чтобы этот список формировался динамически
\item =: Test Runner-у на вход отдается полный список путей к файлам тестовых контейнеров
\item =: LTUE сами производят загрузку своих тестовых контейнеров
\item Факт: прежде чем загрузить тестовый контейнер нужно подгрузить все LTUE
\item =: список LTUE отдается Test Runner-у вместе со списком файлов
\end{enumerate}
\divblock{==============================}
% тесты распознаются по расширению
\begin{enumerate}[]
\item Факт: тестовые контейнеры могут быть как текстовыми файлами, так и бинарными
\item =: LTUE сами производят загрузку своих тестовых контейнеров
\item Факт: файлы отличаются именем и расширением
\item Факт: текстовые файлы могут иметь разные кодировки
\item Факт: в начале тела текстовых файлов могут находиться служебные метки, например, BOM
\item Факт: содержимое текстовых файлов может быть записано с использование широких и узких символов
\item Факт: формат бинарных файлов DLL, генерируемых VS сложен
\item $\to$ Предположение: заглянуть в файл тестового контейнера даже одним глазком будет непросто
\item $\to$ $\to$ Предположение: не получиться решить проблему меткой внутри тестового контейнера
\item \quad Факт: ОС обычно понимает какая программа может открыть тот или иной файл по его расширению
\item $\to$ $\to$ =: Различать тестовые контейнеры нужно по имени и расширению 
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item =: Различать тестовые контейнеры нужно по имени и расширению 
\item Факт: имя от расширения отделяется точкой
\item Факт: подчеркивание -- допустимый символ в имени файла и он часто используется для разделения слов друг от друга
\item Факт: определить текстовый файл или бинарный можно по расширению
\item Факт: файлы одного компонента связаны общим префиксом имени (от начала до первой точки)
\item $\to$ Предположения: нужно дополнительное расширение в имени файла обозначающее, что это файл не с прикладным, а с тестовым кодом, например, t
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Предположения: нужно дополнительное расширение в имени файла обозначающее файл с тестовым кодом, например, t
\item Предположение: скрипт-main может не знать все LTUE, необходимые для загрузки тестовых контейнеров
\item $\to$ Предположение: смогут загрузиться не все указанные Test Runner-у файлы тестовых контейнеров
\item Предположение: будет проще, если скрипт-main будет общим для загрузки тестовых контейнеров любого из LTUE
\item Предположение: Test Runner заранее не знает как определить какие тестовые контейнеры какими LTUE могут быть загружены
\item $\to$ =: Test Runner должен спрашивать у LTUE может ли он загрузить тот или иной тестовый контейнер
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: есть leda -- библиотека Lua на wchar\_t. 
\item Факт: скриптам, написанным под leda необходимо выполняться в рамках VM Leda
\item Факт $\ominus$: luaunit (Lua Test Unit Engine), использующий стандартную Lua не в состоянии корректно выполнять тесты для Leda
\item Факт $\oplus$: архитектура yunit предполагает расширение набора Language Test Unit Engine-ов
\item =: Необходимо сделать отдельный LTUE -- ledaunit, который:
    \begin{itemize}
    \item может загрузить и выполнить скрипт под Leda
    \item выставляет тот же интерфейс (в стандартную Lua), что и luaunit, cppunit, чтобы Test Runner мог с ним общаться
    \end{itemize}
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: ledaunit-у необходимо выставиться в стандартную Lua на узких символах (т.е. использовать \path{lua/lua.h} и линковать lua5.1.lib)
\item Факт: ledaunit-у необходимо использовать C API Leda, чтобы выполнять свои тесты (т.е. использовать \path{leda/lua.h} и линковать leda.lib)
\item Предположение: тесты к ledaunit-у -- это отдельные текстовые файлы
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: для написания модульных тестов нужно использовать yUnit, установленную в системе
\item $\to$ Предположение: ledaunit должен линковать Lua из yUnit, т.е. динамически
\item Факт: функции из C API Lua и Leda имеют одинаковые имена
\item $\to$ чтобы использовать их одновременно нужно линковать один статически, другой -- динамически
\item $\to$ $\to$ Предположение: ledaunit-у придется линковать leda статически
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: расширением пользуется ОС
\item Предположение: расширение не должно быть длинным
\item Leda -- это Lua на широких символах wchar\_t, но по идее, это другой диалект языка
\item $\to$ Предположение: выбрать для leda-скриптов расширение \path{leda}
\item $\to$ Предположение: для разных диалектов одного языка использовать разные расширения
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Противоречие: 
\item Факт: что можно сделать на Lua, то можно сделать и с использованием C API Lua
\item Факт: трудоемкость реализации на C API Lua выше, чем на Lua
\item Факт: ledaunit придется содержать ту же функциональность, что любой другой LTUE
\item $\oplus$ ledaunit может полностью использовать код luaunit
\item $\ominus$ код luaunit в этом случае должен выполниться в рамках VM Leda
\item Факт: нет интерпретатора Leda, есть только библиотека
\item =: Код luaunit нужно будет сконвертировать в UCS2 и переименовать в \path{ledaunit.leda}. ledaunit будет выступать за интерпретатор Leda и загрузит его внутри себя 
    \begin{itemize}
    \item $\ominus$ будет дублирование кода luaunit, но только в другой кодировке
    \item $\oplus$ трудоемкость реализации ниже
    \end{itemize}
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item =: Ledaunit, как LTUE, реализован в виде \path{ledaunit.dll}
\item =: основная функциональность содержится в \path{ledaunit.leda}
\item $\to$ Предположение: задачей \path{ledaunit.dll} будет только загрузить \path{ledaunit.leda} и перебрасывать вызовы из VM Lua в VM Leda и ответы в др. сторону. Т.е. основное назначение -- выставиться в Lua.
\end{enumerate}

%-----------------------------------------------------------------------------------------
\subsection{Требования с совещания 11 декабря 2010 г.}

%-------------------------------------------------------------------------------------------------------------
\section{Issures}
\begin{itemize}
\item Каждому загружаемому тестовому контейнеру нужны свои значения для переменных среды % и определенная рабочая папка при выполнении % выполнено.
\item Зачем использованы Thunk-и, можно ли обойтись без них?
\item Закрыв каждый тест своим namespace-ом можно защитить их от <<глобальных>> переменных друг друга\footnote{Это наверное относиться не к C++, а к Lua. Сами тесты не смогут объявить объект в области вне своей функции}.
\item В коде теста могут вызываться как C++, так и SEH исключения. Они не должны <<валить>> прогон тестов, но после SEH его нужно корректно остановить, т.к. состояние процесса уже может быть катастрофическим.
\item Использовать лямбда функции (и std::function) из стандарта 0xC++ вместо Thunk.
\item Защита от бесконечных циклов внутри тестов.
\item Защита от неожиданного SEH исключения в тесте конкретного тестового контейнера. Т.е. чтобы можно было бы не останавливать полностью прогон тестов, а пропустить только тесты одного тестового контейнера.
\end{itemize}



