%--template 'template.tex' --def title='Краткий обзор Луны 5.1' --def author='\we'

\section{Обзор}

Lua "--- скриптовый язык, предназначенный для встраивания в приложения, написанные на C. Фактически оригинальная реализация Lua представлена в виде библиотеки. Используя ее открытый интерфейс, host-программа управляет виртуальной машиной Lua.

%-------------------------------------------------------------------------------------------------------------
\section{Структура папок установленной Луны}

Описанная дальше схема установки интерпретатора Lua и модулей под него является некоторой схемой по-умолчанию, чтобы навести некоторый порядок в его использовании и избежать полного хаоса и анархии. Однако, не стоит при написании кода рассчитывать, что кто-либо будет вообще ее придерживаться.

\begin{figure}[htbp]
\psset{mcol=l,rowsep=0.5ex,colsep=0em,nodesep=5pt,arm=0.5em,angleA=270,angleB=180}
\begin{psmatrix}
\path{lua} \\
& \path{ 5.1 } \\ \ncangle{1,1}{2,2}
& & \path{lua5.1.exe} \\    \ncangle{2,2}{3,3}
& & \path{lua5.1.dll} \\    \ncangle{2,2}{4,3}
& & \path{module1.dll} \\   \ncangle{2,2}{5,3}
& & \path{lua} \\           \ncangle{2,2}{6,3}
& & & \path{module2.lua} \\ \ncangle{6,3}{7,4}
& & & \path{module3} \\     \ncangle{6,3}{8,4}
& & & & \path{init.lua} \\  \ncangle{8,4}{9,5}
\path{ ... }
\end{psmatrix}
\caption{Структур каталогов в рабочей копии} \label{fig:lua_install_directory}
\end{figure}

Необходимо уточнить, что корневую директорию дерева \eqref{fig:lua_install_directory} лучше расположить в корне какого-нибудь диска, например, системного, который определяется переменной среды \verb|%SYSTEMDRIVE%|. Это позволит в будущем избежать ситуации, когда совершенно необходимый и нужный модуль не выносит путей к файлам, содержащим пробелы, или тем более иностранные (для англоязычных хомо сапиенсов) буквы.

Указывать версию в имени папки все-таки полезно по двум причинам:
\begin{enumerate}
\item Не нужно плодить дополнительный уровень вложенности папок
\item С выходом новой версии интерпретатора (не какого-нибудь патча, а нормальной версии, в которой изменился сам язык -- в лучшую сторону, естественно, добавлены различные удобные фишки и т.д.) начинается чехарда с тем, что какие-то модули с новой версией совместимы, а какие-то -- нет. Далее разработчики судорожно начинают подстраиваться, выпускать новые версии модулей, которые, в свою очередь, могут не захотеть работать под старой версией. Чтобы не зарабатывать головную боль, пытаясь отслеживать все эти изменения, и не требовать потом у фармацевта из соседней аптеки таблетку аспирина, размером с кирпич, нужно с выходом новой версии Lua, просто породить новую папку типа luax.x и уже работать только с ней.
\end{enumerate}

Схема установки модулей Lua подстраивается под ту схему поиска модулей, которой придерживается интерпретатор, когда не заданы переменные среды \verb|LUA_PATH| и \verb|LUA_CPATH|. А именно:
\begin{enumerate}
\item Если модуль представляет из себя одинокую dll, то ее нужно положить прямо рядом с интерпретатором, чтобы ей одной было не скучно;
\item Если модуль -- это единственный скрипт, то копируем его в подпапку \path{lua};
\item Если модуль достаточно "<упитанный">, чтобы уменьшаться только в нескольких скриптах, то ему нужно выделить отдельный каталог в подпапке \path{lua} и в ней скрипт \path{init.lua} через который модуль и будет инициализироваться, т.к. именно этот скрипт будет запускаться командой require при поиске этого модуля.
\end{enumerate}

Одновременная установка нескольких версий одного пакета не подразумевается.

Непосредственно в дистрибутиве Lua лежит файл-иконка \path{luafile.ico}, ее можно ассоциировать с файлами \path{*.lua}. Либо это производится ручками через "<Свойства папки"> $\to$ "<Типы файлов">, либо при помощи дистрибутива. Последнему для этого приходится править ветку реестра \path{HKEY_CURRENT_USER\Software\Classes}: запускаться-то он должен из-под обычного пользователя. При этом ассоциации какого-либо приложения с этим типом файлов производится не будет, будет ассоциация только иконки. Если файлы скриптов Lua уже были до этого с кем-то ассоциированы, то будет, опять-таки переассоциирована только иконка.

Если вы используете SciTe для редактирования скриптов на Lua, то пропишите у него в пользовательских настройках следующий пункт:
\begin{verbatim}
# For run simple lua scripts
command.go.*.lua=lua5.1.exe "$(FileNameExt)"
\end{verbatim}



-------------------------------------------------------------------------------------------------------------
% \section{Встраивание Lua в C}

% Простейший пример интеграции Lua в C:

% \begin{lstlisting}[style=cpp]
% #include "lua.h"
% #include "lauxlib.h"
% #include "lualib.h"

% int main()
% {
%     lua_State* L = luaL_newstate();

%     luaL_openlibs(L);

%     luaL_dofile(L, "code.lua");

%     lua_close(L);
% }
% \end{lstlisting}

% Первое, что необходимо сделать "--- создать новое состояние (виртуальную машину) Lua. Это выполняется функцией \lstinline|luaL_newstate|. Количество виртуальных машин в одной программе ограничивается только объемом доступной памяти. Все созданные виртуальные машины полностью независимы друг от друга, имеют уникальные состояние и стек.

% Второй этап "--- загрузка стандартной библиотеки. Функция \lstinline|luaL_openlibs| делает доступными для кода на Lua все функции стандартной библиотеки. Вообще это не является обязательным, просто эти функции невозможно будет использовать.

% Следующий этап "--- загрузка и выполнение кода на Lua. Функция \lstinline|luaL_dofile| загружает указанный файл, компилирует исходный код в байт-код и выполняет его. Вместо (или вместе с) \lstinline|luaL_dofile| может быть использована функция \lstinline|luaL_dostring|, которая вместо имени файла принимает соответственно строку кода на языке Lua (например, \lstinline|luaL_dostring(L, "print('Hello')")|. В любом случае, исходный код будет преобразован в байт-код и немедленно выполнен на соответствующей виртуальной машине.

% Единица исходного кода, исполняемая за один раз, в Lua называется chunk. В нашем примере chunk'ом будет являться весь код в файле code.lua. Если использовать \lstinline|luaL_dostring|, то chunk'ом будет строка, подаваемая на вход. В рамках одной виртуальной машины может быть выполнено сколь угодно много chunk'ов. Все они разделяют ее состояние, т.е. могут обращаться к одним и тем же глобальным переменным и функциям. Более того переменная может быть определена в одном chunk'е, а использована в другом (главное соблюсти порядок выполнения chunk'ов).

% Когда host-программа наигралась с Lua, она должна вызвать \lstinline|lua_close| для нужной виртуальной машины (их может быть и несколько), чтобы освободить занятые ресурсы.



-------------------------------------------------------------------------------------------------------------
% \section{Расширение Lua}

% Lua можно расширить за счет функций, написанных на C. Строго говоря, вся стандартная библиотека Lua реализована именно таким образом.

% Для примера попытаемся встроить функцию, возвращающую квадрат числа. Такая функция на C выглядит так:

% \begin{lstlisting}[style=cpp]
% int squareFunc(lua_State* L)
% {
%     lua_Number number = lua_tonumber(L, -1);

%     lua_pushnumber(L, number * number);

%     return 1;
% }
% \end{lstlisting}

% Сначала получили переданный аргумент функцией \lstinline|lua_tonumber|. Выполнив возведение в квадрат, помещаем в стек результат "--- \lstinline|lua_pushnumber|. Возвращаемое значение в C соответствует количеству возвращенных значений в Lua.

% Последним шагом будет регистрация нашей функции под именем ``myfunc'' в виртуальной машине:

% \begin{lstlisting}[style=cpp]
% lua_register(L, "myfunc", squareFunc);
% \end{lstlisting}

% К слову, точно так же можно переопределить и стандартную функцию, например \lstinline|print|. После регистрации (а ее можно сделать в любое время, даже между исполнением chunk'ов) код на Lua сможет использовать нашу функцию, например

% \begin{lstlisting}[style=cpp]
% luaL_dostring(L, "print(myfunc(12))");
% \end{lstlisting}

% В результате выполнения этого chunk'а на экран будет выведено значение \lstinline|144| (конечно если не переопределена функция стандартной библиотеки \lstinline|print|).

