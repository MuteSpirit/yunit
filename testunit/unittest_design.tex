%--template 'shared_template.tex' --def title='Модульное тестирование' --def author='\we' --def today='???'

\newcommand{\reason}[1]{\footnote{\fbox{\parbox{\textwidth}{\textbf{Причина:}\\ #1}}}}

\newcounter{faqCount}
\setcounter{faqCount}{0}
\newcommand{\FAQbegin}{}
\newcommand{\FAQend}{\medskip\hrule}
\newcommand{\fastQ}{\addtocounter{faqCount}{1}\medskip\hrule\medskip{\red Q\arabic{faqCount}?}\quad}
\newcommand{\fastA}{{\blue A:}\quad}

%-------------------------------------------------------------------------------------------------------------
\section{Введение}
Модульное тестирование (unit test) "--- это тестирование отдельных функций исходного кода программы или программного комплекса. Модульное тестирование является одним из видов тестирования, выполняемых в рамках обеспечения надежности разрабатываемого ПО\footnote{Добавить ссылку на документ по надежности?}.

Для выполнения модульного тестирования требуется библиотека, упрощающая программирование и выполнение модульных тестов, кодовое наименование unit\_test, и документация\footnote{Документ по дизайну движка для модульных тестов находится в пакете testunit (\path{unittest_design.tex}). В документе \path{programmers_guide} содержится раздел с описанием вариантов использования} с рекомендациями по программированию тестов и регламентами тестирования.

%-------------------------------------------------------------------------------------------------------------
\section{Список терминов и сокращений}

\begin{tabulary}{\textwidth}{p{\textwidth}}
{\bfseries <<Движок>>/библиотека модульных тестов (Test Unit Engine)} -- вся библиотека testunit как отдельный пакет \\
{\bfseries Контейнер тестов (Test Container)} -- файлы, содержащие набор тестов в некотором формате (\path{*.t.dll}, бинарный формат в случае тестов на C++ (C++ Test Container) и \path{*.t.lua}, текстовый формат в случае тестов на Lua (Lua Test Container)\\
{\bfseries Тестовый драйвер (Test Driver)} -- это набор тестов и сценарий запуска для содержащихся в них тестов \\
{\bfseries <<Запускалка>> тестов (Test Runner)} --  та часть функциональности библиотеки testunit, которая отвечает за поиск, загрузку тестовых контейнеров, получение из них списков тестов, их запуск и публикация результатов прогона тестов \\
{\bfseries <<Движок>> тестов для определенного языка программирования (Programming Language Test Engine)} -- та часть функциональности библиотеки testunit, которая отвечает за синтаксис тестов, набор тестовых проверок, составление коллекции тестов в Test Container-е и защищенный вызов тестовых функций для тестов, написанных на определенном языке программирования. На данный момент реализованы два таких <<движка>>: C++ Test Engine и Lua Test Engine \\
{\bfseries } Тест кейс (контрольный пример) (Test Case) -- один отдельный тест \\
{\bfseries } Набор тестов (Test Suite) -- набор тест кейсов \\
\end{tabulary}

%-------------------------------------------------------------------------------------------------------------
\section{Анализ предметной области}

Выделим семейство процессов разработки с использованием модульных тестов:
\begin{itemize}
\item разработка прикладного кода на C++ 
\item разработка прикладных кода на Lua
\item разработка кода С++, выставленного в Lua, и тесты на Lua к нему (гетерогенная разработка)
\end{itemize}

Общими для семейства являются:
\begin{itemize}
\item работаем в среде разработки
\item пишем тесты на языке разработки
\item запускаем тесты на выполнение
\end{itemize}

Разработка в стиле TDD или без него -- не важно, это положительная изменчивость.

Отрицательная изменчивость -- запуск тестов при помощи Hudson, он не разрабатывает, а только запускает тесты (прогон вне среды).

Использование генератора кода (либо чего-то другого) для создания оберток в Lua считаем выходящим за рамки данного анализа, и вообще плохим вариантом.

Разработка скриптов на Lua в рамках и для ГеПарта также выходит за рамки данного семейства, т.е. из разработчиков остаемся только мы, заказчики -- нет.

%-------------------------------------------------------------------------------------------------------------
\section{Особенности модульного тестирования}

С технической точки зрения модульное тестирование заключается в выполнении тестируемых функций на некотором множестве исходных данных и сверке получаемых результатов с заранее известными с целью установить соответствие функции ее спецификации.

Таким образом, элементарный тест (test case) представляет собой программу, осуществляющую:
\begin{enumerate}
\item подготовку исходных данных;
\item выполнение тестируемой функции;
\item сверку полученных результатов с ожидаемыми;
\item освобождение использованных ресурсов;
\item вывод результата проверки.
\end{enumerate}

Для написания тестов используется тот же язык, что и для написания тестируемого кода.

Программирование теста осуществляется в соответствии с образцами xUnit: проверка (Assertion), фикстура (Fixture), внешняя фикстура (External Fixture), тестовый метод (Test Method), тест исключительной ситуации (Exception Test). 

Для убедительной проверки соответствия функции ее спецификации требуется выполнить набор тестов (test suite). Задача о выборе набора тестов для проведения модульного тестирования рассматривается в общем документе по тестированию\footnote{см. \path{programmers_guide}}. 

Минимальной единицей исходного кода, которая включается в состав программы, выполняющей тесты, является минимальная физическая единица исходного кода "--- компонент (component, группа файлов с одинаковым именем \path{name.*}), содержащая набор функций, возможно объединенных в классы, которые составляют законченную часть логического дизайна.

Тестирование компонентов выполняется в рамках программирования пакета (Package), объединяющего группу логически и физически связанных компонентов в атомарную единицу процесса сборки.

ПК, состоящие из множества компонентов, требуют специальных способов организации процессов модульного тестирования. Для упрощения тестов, уменьшения их числа, быстрой локализации ошибки и легкой отладки используется восходящее модульное тестирование. Оно выполняется программистами в процессе создания исходного кода и подразумевает последовательное автоматизированное тестирование зависимых компонентов начиная с нижних уровней.

Следующие атрибуты тестов указывают на плохой дизайн прикладного кода:
\begin{enumerate}[--]
\item Длинный код инициализации. Если вы вынуждены написать сотни строк кода, создавая объекты для одного просто оператора ASSERT, значит что-то не так. Это означает, что ваши объекты слишком большие и их требуется разделить.
\item Дублирование кода инициализации. Если вы не можете быстро найти общее место для общего кода инициализации, это означает, что у вас слишком много объектов, которые слишком тесно взаимодействуют друг с другом.
\item Тесты выполняются слишком медленно. Если тесты TDD работают слишком медленно, значит, они не будут запускаться достаточно часто. Значит программист будет в течение некоторого времени работать, вообще не запуская тестов. Значит, когда он их все-таки запустит, скорее всего, многие из них не сработают. Иными словами, улучшив дизайн, вы можете увеличить скорость работы тестов.
\item Хрупкие тесты. Если ваши тесты неожиданно начинают ломаться в самых непредсказуемых местах, это означает, что одна часть разрабатываемого приложения непредсказуемым образом влияет на работу другой части. В этом случае необходимо улучшить дизайн таки образом, чтобы данный эффект исчез. Для этого можно либо устранить связь между частями приложения, либо объединить две части воедино.
\end{enumerate}

%-------------------------------------------------------------------------------------------------------------
\section{Варианты использования модульных тестов}

%-------------------------------------------------------------------------
\subsection{Разработка компонента}

Открываем компонент (для C++ -- это файлы \path{*.h}, \path{*.cpp} и \path{*.t.cpp}) в IDE (или подходящего редактора, который "<обвешан"> скриптами для работы с модульными тестами\footnote{Не ждите пока любимый только Вами, но не используемый другими разработчиками редактор будет соответствующим образом "<накачан"> скриптами, сделайте это сами. Список того, что будет поддерживаться однозначно -- это MS Visual Studio и SciTE.}). Подразумевается, что все используемые текущим компоненты уже протестированы.

Выбираем для проекта конфигурацию "<test">. Результатом сборки будет тестовый драйвер (Test Driver). При помощи него становиться возможным запуск содержащихся в нем тестов. Но поскольку мы вносим изменения в один компонент, то будет достаточным прогон только тестов, относящихся к нему.

Намечаем изменения, которые необходимо внести в компонент. Пишем в файле тестов (\path{*.t.cpp} -- для C++) новые тесты, проверяющие поведение кода согласно последней спецификации, либо подправляем уже имеющиеся. Затем производим сборку проекта и запуск тестов, для удобства эти два действия должны выполняться вспомогательным скриптом в одну атомарную операцию. Убеждаемся, что новые тесты провалились\footnote{А то вдруг и делать-то уже ничего не надо и код уже отвечает спецификации :-) }. Вносим изменения в основной код, опять запускаем тесты, смотрим какие из них завершились с ошибкой, исправляем код, опять прогоняем тесты и так до тех пор пока не будут проходить все тесты. 

%-------------------------------------------------------------------------
\subsection{Сдача кода в репозиторий}

Если делаете доставку пакета, то прогоните перед этим все его модульные тесты, если группу пакетов -- тесты всех пакетов, входящих в эту группу.

%-------------------------------------------------------------------------
\subsection{"<Night Build">}

На сервере автоматически выполняется сборка и модульное тестирование значительного количества компонентов (например, всех), находящихся в хранилище исходного кода. И потом с утречка программисты будут "<радоваться">, читая списки завалившихся ночью тестов. 

Можно подобную операцию выполнять дважды в сутки -- в обед и собственно ночью. А в качестве наказания за проваленную сборку можно назначать виновного отвечать за подобные полные сборки до тех пор, пока кто-нибудь еще не облажается.

%------------------------------------------------------
\section{Описание проблемы}

% \newcommand{\question}[1]{\fbox{\parbox{0.05\textwidth}{\huge\textbf{?}}}\fbox{\parbox{0.9\textwidth}{\quad #1}}}

% \newcommand{\question}[1]{%
%     \begin{tabular}{|c|c|}
%     \hline
%     &\\
%     \parbox[c][\totalheight][c]{1em}{\Huge\textbf{?}}&\parbox{.85\textwidth}{#1}\\
%     &\\
%     \hline
%     \end{tabular}
% }%

Есть требования, которым должен отвечать библиотека для работы с модульными тестами:
\begin{itemize}
\item Нужно уметь прогонять тесты для приложений на любом из используемых нами языков; 
\item Нужно уметь определять состав имеющихся тестов;
\item Нужно уметь запускать из всех тестов только определенные их наборы. Набор (коллекция) тестов может состоять как из одного теста, так и из всех тестов сразу;
\item Нужно уметь производить эти запуски удаленно, в несколько параллельных запусков (от разных пользователей), с ведением централизованных логов, с сохранением результатов в централизованную базу знаний\footnote{для последующего анализа менеджером проекта} и т.п.
\item Нужно уметь "<публиковать"> результаты тестов на обозрение разработчиков;
\item Нужно уметь прогонять тесты не только для наших проектов, но и для внешних\footnote{Конечно, обвешивание тестами готового проекта чрезвычайно сложно, но иногда может и понадобиться};
\item Нужно стремиться к минимизации времени реакции на запуск тестов. Весь прогон тестов должен быть настолько быстрым, что его было бы комфортно запускать разработчику как можно чаще;
\item Нужно уметь запускать всякие "<NightBuild">-ы полностью в автоматическом режиме, по расписанию и т.д.
\item Нужно уметь интегрировать управление запуском тестов в используемые IDE.
\end{itemize}

Кроме читабельных сообщений в output-е необходимы данные, на которые мог бы опираться скрипт выполняемый без участия человека. Т.е. в результате прогона теста скрипт должен знать о кол-ве успешних и кол-ве провалившихся тестов, их имена и сообщения об ошибках. Крах одного из тестом может означать остановку компиляции и запустка тестов всех пакетов, зависящих от того, чей тест грохнулся\footnote{Выяснение зависимостей между пакетами -- это другая задачка, просто смежная, в "<Large Scale">, в приложении С должно быть краткое описание этого процесса}. 

При проектировании решения надо отталкиваться от следующих предпосылок:
\begin{itemize}
\item Движок для запуска тестов нужно писать на Lua;
\item Пока при разработке из языков программирования мы будем использовать Lua и C/C++;
\item Придется уметь работать с такими IDE как MS Visual Studio и SciTE;
\item Всякие удаленные сборки будут запускаться с использованием LIWSI;
\item Переносимость приветствуется;
\end{itemize}

Создание интерфейса для Lua приследует одну мегацель -- это автоматизированный процесс восходящего регрессионного тестирования всего кода, который мы успели (и еще успеем) наколотить. В этот интерфейс должны входить такие функции, которых хватило бы на реализацию веб интерфеса, позволяющего разработчику несколькими щелчками мыши запускать тестовые модули только что закоммиченного пакета -- прям с пылу с жару новые фичи -- и всех пакетов, от которых он зависит (ну или вообще всех имеющихся), чтобы можно было лелеять достаточную надежду на то, что внесенные изменения не приводят код в инвалидное состояние. Джоэл Спольки предлагал повинности для таких программистов в виде обязанности выполнять регулярные сборки кода и дистрибутивов, пока кто-нибудь другой не сделает такой же косяк.

\pagebreak
%-------------------------------------------------------------------------------------------------------------
\section{Особенности реализации}

%-----------------------------------------------------
\subsection{Cхема расположения файлов в рабочей копии}

\begin{figure}[htbp]
\centering
\psset{mcol=l,rowsep=0.5ex,colsep=0em,nodesep=5pt,arm=0.5em,angleA=270,angleB=180}
\begin{psmatrix}
& \path{..}   \\ 
& \path{_bin} \\
& & \path{lua5.1.exe} \\
& & \path{lua5.1.dll} \\
& & \path{cppunit.dll} \\
& & \path{package1.dll} \\
& & \path{package1.t.dll} \\
& \path{_lib} \\
& & \path{lua5.1.lib} \\
& & \path{package2.lib} \\
& \path{testunit}    \\
& & \path{test_runner.lua}  \\
& & \path{test_listeners.lua}  \\
& & \path{test.h}           \\
& \path{lua}   \\
& & \path{lua.h}      \\
& & \path{lualib.h}      \\
& & \path{luaxlib.h}      \\
& \path{package1}   \\
& & \path{_misc}      \\
& & & \path{*.sqlite}      \\
& & & \path{*.txt}      \\
& & \path{*.h}      \\
& & \path{*.cpp}    \\
& & \path{*.t.cpp}  \\
& & \path{*.lua}    \\
& & \path{*.t.lua}  \\
\ncangle{2,2}{3,3}
\ncangle{4,2}{5,3} \ncangle{4,2}{6,3} \ncangle{4,2}{7,3} \ncangle{4,2}{8,3} \ncangle{4,2}{9,3}
\end{psmatrix}
\caption{Схема рабочей копии} \label{fig:tests_at_working_copy}
\end{figure}

Причины подобной схемы расположения файлов можно узнать в главе <<Рабочее пространство>> документа <<Руководства программиста>>. К описанию из этой главы можно добавить некоторые подробности, касающиеся тестов:
\begin{itemize}
\item Файлы скриптов Lua (\path{*.lua}) и тестов к ним \path{*.t.lua} располагаются внутри пакетов\reason{Они являются файлами исходного кода, а не бинарниками, которым для запуска могут понадобиться внешние библиотеки и проще, если они будут лежать рядом}.
\item Пакет \path{testunit} обязателен для использования модульных тестов.
\item Иногда для тестов нужны вспомогательные файлы (БД, бинарные и текстовые файлы, образы виртуальных машин и пр.), они лежат в отдельной подпапке пакета с именем \path{_misc}. Их наличие или отсутствие -- лично дело разработчика пакета.
\item "<Плюсовый"> тестовый драйвер собирается в динамически загружаемую библиотеку \path{*.t.dll} или \path{*.t.so} в папку \path{_bin}.
\item Для сборки Test Container и запуска тестов используются библиотека и интерпретатор Lua, находящиеся в рабочей копии\reason{Это делает среду рабочей копии еще более независимой от среды операционной системы и установленных в ней компонентов}.
\end{itemize}

%-----------------------------------------------------
\subsection{Составные части}

Библиотека модульных тестов состоит из трех основных частей:
\begin{itemize}
\item <<плюсовый>> движок модульных тестов;
\item <<луновый>> движок модульных тестов;
\item <<запускалка>> тестов.
\end{itemize}

C++ Test Engine и Lua Test Engine аналогичны по архитектуре, но написаны на разных языках. Они содержат ту функциональность, которую не получиться вынести в Test Runner по причине языковых особенностей:
\begin{itemize}
\item механизм сбора тестов;
\item макросы проверки, обеспечивающие самопроверяемость тестов, они уникальны для каждого языка из-за типов данных переменных, проходящих проверку;
\item реализация синтаксиса написания тестов;
\item реализация защищенного вызова фукнции, что не позволяет одному заваленному тесту повалить весь процесс прогона тестов.
\end{itemize}

%-----------------------------------------------------
\subsection{Основные классы}

\begin{itemize}
\item Test -- абстрактный базовый класс тестов, содержит виртуальную фукнцию test()
\item TestFixture -- базовый класс, содержит виртуальные фукнции setUp() и tearDown()
\item TestCase -- базовый класс тестов, производный от Test и TestFixture содержит пустые setUp() и tearDown(). Чтобы в тесте иметь возможность использовать некоторые разделяемые ресурсы, то необходимо сначала создать "<живую"> TestFixture и унаследовать от нее конкретный класс TestCase-а.
\item TestSuite -- набор тестов, содержит список TestCase-ов
\item TestRegistry -- реестр тестов
\item TestObserver -- объект, получающий сообщения по ходу выполнения тестов и рассылающий их всем подписавшимся TestListener-ам
\item TestListener -- выводит сообщения о тестах туда, где их будет смотреть разработчик
\item TextTestProgressListener -- выводит сообщения о тестах в output в виде простого текста
\end{itemize}

%-----------------------------------------------------
\subsection{Механизм сбора тестов}

Этот механизм включает в себя создание объектов TestCase и их регистрация в реестре тестов.

В C++ Test Engine сбор TestCase-ов из всех файлов \path{*.t.cpp} производится за счет создания глобальных объектов классов-регистраторов, они создают в своем конструкторе статический объект конкретного класса, и регистрируют их в общем реестре "<плюсовых"> тестов (TestRegistry). Так регистрируются TestCase и TestSuite. Получается что в момент загрузки тестового контейнера (файла \path{*.t.dll} или \path{*.t.so}) инициализируются все глобальные объекты и Test Registry оказывается заполнен списком всех тестов. При таком способе управлять составом тестов можно управлять только на этапе компиляции, включая/исключая файлы тестов (\path{*.t.cpp}) из компиляции.

В Lua Test Engine происходит аналогичный процесс, но только в отношении Lua. 

Для инкапсуляции от пользователей этих подробностей используются макросы (C++) или функции (Lua):
\begin{itemize}
\item TEST\_SUITE(testSuiteName)
\item TEST\_CASE(testName)
\item TEST\_CASE\_ALONE(testName)
\item TEST\_CASE\_EX(testName, fixtureName)
\item TEST\_CASE\_EX\_ALONE(testName, fixtureName)
\item TEST\_CASE\_END
\end{itemize}

Если TEST\_CASE используется внутри TEST\_SUITE, то соответствующий тест попадает в список Test Suite. 
TEST\_CASE\_ALONE поволяет определять Test Case вне рамок определенного пользователем Test Suite-а, он будет помещен в Test Suite по умолчанию. 

Test Case начинается любым из макросов TEST\_CASE*, но должен завершаться макросом TEST\_CASE\_END.

%-----------------------------------------------------
\subsection{<<Запускалка>> тестов}

Одна из главных задач test\_runner-а -- это при помощи выставленных в Lua функций тестовых драйверов cpp\_unit и lua\_unit загрузить последние и получить от них "<луновые"> объекты с интерфейсом TestCase-а, т.е. имеющими фукнции setUp, test и tearDown и поле name\_. Ненужные тесты отфильтровываются (при этом из памяти объекты тестов не удаляются), а остальные проходят "<рамку теста">.

"<Рамка теста"> представляет из себя последовательный вызов фукнций \verb|setUp()|, \verb|test()| и \verb|tearDown()|, плюс в нужные моменты TestObserver-у посылаются сообщения о тестах (какой тест начал выполняться, как завершился, какой завершился и т.п.). Функция \verb|test()| не будет вызвана, если завершилась с ошибкой \verb|setUp()|. Если все-таки \verb|setUp()| выполнилась успешно, но будет вызвана \verb|test()| и обязательно -- \verb|tearDown()|. С помощью фукнций \verb|setUp()| и \verb|tearDown()| Вы можете инициализировать тестовую среду до выполнения теста и привести систему в исходное состояние после выполнения теста, чтобы не  мешать выполнению других тестов.

"<Плюсовые"> тестовые драйверы загружаются следующим образом. Во-первых, в память загружается динамическая библиотека самого cpp\_unit-а:\\ \verb|local getTestList = package.loadlib("../_bin/cppunit."..dllExt, "getTestList")|,\\ затем тестовые драйверы: \\ \verb|package.loadlib("../_bin/*.t."..dllExt, "")|.\\ Все тестовые драйверы используют объекты и фукнции, экспортируемые динамической библиотекой cpp\_unit-а, поэтому загруженные в текущий процесс динамические библиотеки тестовых драйверов имеют общие глобальные объекты, а следовательно пользуются одним реестром "<плюсовых"> тестов, в который вновь подгружаемый тестовый драйвер старательно складывает все свои тесты во время инициализации своих глобальных объектов.

"<Луновые"> тестовые драйверы грузятся банальнейшим образом -- при помощи фукнции dofile.

Т.к. подавляющий объем кода находится в test\_runner и он "<луновый">, то это упрощает процесс разработки и поддержки проекта за счет большей скорости разработки на скриптовом языке. Особенно это скажется при написании сложных TestListener-ов, коих нам понадобиться несколько типов, выдающих, например, полученные сообщения в определенном формате (txt, html, http-запрос) и на определенный приемник (консольный вывод, файл, syslogd, веб-сервер, Jabber Client). Для того, чтобы можно было на некотором количестве тестов запускать несколько наборов тестов без перезапуска, либо порождения отдльного процесса, нужно, чтобы при фильтрации списка запускаемых TestCase-ов сами объекты этих TestCase-ов не удалялись из памяти.

%-----------------------------------------------------
\subsection{Макросы проверки}

Для тестов на C++ доступны следующие макросы:
\begin{itemize}
\item ASSERT(condition)
\item ASSERT\_NOT(condition)
\item ASSERT\_NOT\_EQUAL(expected, actual)
\item ASSERT\_DOUBLES\_NOT\_EQUAL(expected, actual, delta)
\item ASSERT\_THROW(expression, exceptionType)
\item ASSERT\_NO\_CPP\_EXCEPTION_THROW(expression, exceptionType)
\item ASSERT\_NO\_ANY\_CPP\_EXCEPTION(expression)
\end{itemize}

а для тестов на Lua:
\begin{itemize}
\item ASSERT(assertion)
\item ASSERT\_TRUE(actual)
\item ASSERT\_FALSE(actual)
\item ASSERT\_THROW(functionForRun, ...)
\item ASSERT\_NO\_THROW(functionForRun, ...)
\item ASSERT\_EQUAL(expected, actual)
\item ASSERT\_NOT\_EQUAL(expected, actual)
\item ASSERT\_NIL(variable)
\item ASSERT\_BOOLEAN(variable)
\item ASSERT\_NUMBER(variable)
\item ASSERT\_STRING(variable)
\item ASSERT\_TABLE(variable)
\item ASSERT\_FUNCTION(variable)
\item ASSERT\_THREAD(variable)
\item ASSERT\_USERDATA(variable)
\item ASSERT\_NOT\_NIL(variable)
\item ASSERT\_NOT\_BOOLEAN(variable)
\item ASSERT\_NOT\_NUMBER(variable)
\item ASSERT\_NOT\_STRING(variable)
\item ASSERT\_NOT\_TABLE(variable)
\item ASSERT\_NOT\_FUNCTION(variable)
\item ASSERT\_NOT\_THREAD(variable)
\item ASSERT\_NOT\_USERDATA(variable)
\end{itemize}

%-----------------------------------------------------
\subsection{Неразрешенные вопросы}

\FAQbegin


\fastQ Какие TestListener-ы нужны?

\fastA \ldots


\fastQ Схема фильтрации запускаемых тестов пока не продумана. 

\fastA Основная мысль в том, чтобы выставлять флаги разрешения выполнения в реестре тестов самого test\_runner-а. Однако, надо отметить, что поскольку тесты содержаться в файлах ("<луновые"> в \path{*.t.lua}, "<плюсовые"> в \path{*.t.dll}), то фильтрацией списка запускаемых тестов можно управлять на двух уровнях: физическом (файлами), логическом (списками уже загруженный тестов).


\fastQ Первоначально задумывалось оставить возможность запускать чисто "<плюсовые"> тесты, используя лишь "<плюсовый"> код, и аналогично для "<луновой"> части. Имеет ли смысл это реализовывать?

\fastA \ldots


\fastQ Сейчас класс TestCase реализован и на Lua и на C++, оправдано ли такое дублирование?

\fastA Если мы оставим только "<плюсовую"> реализацию, то не сможем тогда запускать "<луновые"> тесты без использования "<плюсового"> кода, теряется независимость частей движка.


\fastQ Необходимо ли сменить имя класса TestCase из-за измененной функциональности по сравнению с классической моделью модульных тестов xUnit-а?

\fastA Вероятнее всего. Название нужно придумать.


\fastQ Принадлежность TestCase-а к какому-либо TestSuite-у отражать только в названии?

\fastA Это самый простой способ. Если в общем реестре тестов начать делать иерархии, то это должно быть оправдано, можно опять к этому вернуться, когда более подробно будут проработаны требуемые критерии фильтрации списка выполняемые тестов.


\fastQ А если мы загружаем тестовые модули, собранные для разных версий cppunit, у к-ых одинаковые интерфейсные функции?

\fastA Главное - это чтобы не менялся интерфейс и поведение класса TestCase, а остальное не важно. А если будут отличаться, то мы упадем и все ("<мертвые программы не лгут">). Хотя могут быть сложности с выявлением ошибки подобного типа.


\fastQ В итоге получилось, что в Lua из C++ выставлено только TestCase и фукнция по предоставлению их списка?

\fastA Больше пока ничего выставлять не надо, получается обходиться этим. 


\fastQ Если рассмотреть гипотетическую ситуацию, что у нас не два, три и более языков с модульными тестами, которые необходимо запускать однотипным образом, применяя принцип полиморфизма?

\fastA Ну ситуация-то не такая уж и гипотетическая, ведь можно считать другим языком и язык скриптов, SQL, которыми мы также пользуемся, и еще самые низкоуровневые библиотеки можно писать в рамках ANSI C, что добавляет еще один язык. А что касается о стратегии "<прикинуться как другие">, то можно действовать так: сами языки наверняка имеют C API, нужно просто используя его написать и выставить в Lua тот же набор объектов и фукнций, что и для C++. Хотя такого рода "<заворачивание"> используя и Lua. Главное при этом помнить, что модульные тесты обычно пишутся на том же языке, что и основной код. Если от этого приходиться отказываться, то реализация пошла не тем путем.


\fastQ Это все конечно неплохо выглядит, но при этом собственно файлы с тестами получаются пассивными, их не получится использовать независимо, не прибегая к "<запускалке">

\fastA Ну вариант stanalone теста хорош, когда ковыряешься конкретно в нем и запускаешь его в гордом одиночесве. Но когда необходимо запустить десятки и более тестов и получить по ним СУММАРНУЮ статистику, то ничего не выйдет хорошего. Можно и с придуманной схемой эмулировать такое поведение используя фильтрацию списка запускаемых тестов, ну и еще обвешать в достаточной мере скриптами IDE. Главное ведь не в том, насколько сложна система, а насколько ей удобно пользоваться. При правильном подходе пользователи и разницы-то не почувствуют. Лично у меня для файлов \path{*.t.lua}, к-ые, я считаю по-умолчанию, написаны под lunit, запускаются более заковыристой командой с выполнением предварительного кода, передаваемого Луне в параметре --e. Это самый простой пример.


\fastQ Ну допустим, сделали мы пакет полезного кода, пару модулей на Lua, несколько на C++, и естесственно тесты к ним. Что еще должно находиться в составе пакета (а может быть и нет), чтобы эти тесты можно было прогонять?

\fastA Было бы заманчиво сделать пакет независимым в плане: "<загрузил и все есть">, но это как с компилятором, штука отдельная от собственно кода. Так и запускалка, она ведь может, по-идее использовать кучу сторонних модулей и таскать их с каждым пакетом неразумно. Надо просто принять, что пакет можно "<откомпилировать">, а можно "<протестировать">.


\fastQ Подойдет ли данная модель в случае, когда у нас хостовым приложением является не сам Lua интерпретатор, а какое-нибудь из разработываемых нами приложений?

\fastA Т.е. нужно предусмотреть возможность подмены дефолтового интерпретатора другим. Проблема может быть в том, что у нас, скорее всего, в нашем хостовом приложении будет жестко ограничен набор используемых модулей, урезаны даже стандартные библиотеки и т.п., и оставшегося может просто не хватить для работы движка "<запускалки тестов">. Т.к. еще неизвестно как это будет выглядеть в действительности, то сейчас и рассуждать особо не стоит, как и совсем забывать об этом.
\FAQend

%-------------------------------------------------------------------------
\subsection{w01481. Подобрать схему запуска тестов при работе с MSVC и SciTE}

\FAQbegin
\fastQ Процесс сборки "<плюсовой"> части движка (Cppunit ??)

\fastA Сам CppUnit, входит в состав afl, будет представлять из себя один модуль (см. пост выше), зависит от модулей, где реализованы Thunk и типы данных. Но собирать-то его необходимо в DLL-ку (см. пост выше, чтобы узнать причину), вряд ли весь afl будет использоваться тем же способом, следовательно под его сборку нужно завести отдельный проектник. Библиотеку импорта нужно складывать в \path{_lib}, саму DLL-ку -- в \path{_bin}, т.к. она нужна для тестов различных пакетов, и ее незачем дублировать для каждого. 


\fastQ Сколько "<плюсовых"> тестовых драйверов может быть сделано от одного пакета?

\fastA Наверное, столько же сколько есть проектников в этом пакете. Вопрос только в том, могут ли при этом одни и те же тесты войти в разные тестовые драйверы? По идее каждый из тестов полностью независим и не влияет на запуск других тестов, единственный минус от множественного запуска одного и того же теста -- потеря времени. 

\fastA Не совсем верно, т.к. в одном проектнике могут быть несколько конфигураций (допустим, они отличаются наличием или отсутствием некоторых макросов), считай, каждай имеет свой вариант кода, соответственно и свой набор тестов.


\fastQ Получается, что все тестовые драйверы лежат одной большой кучей, а нам каким-то образом нужно выцепить и запустить лишь несколько из них при разработке одного пакета?

\fastA Получается так. Причем, учитывая, что имя проектника может не совпадать с именем собираемой библиотеки, то их не получится брать в качестве опорной точки в поисках. Проще и надежнее будет в начале имени тестового драйвера указывать имя пакета. 


\fastQ Сейчас за счет использования заголовочных файлов "<плюсовые"> пакеты могут находить друг друга в пределах одной рабочей копии, можно создавать локальные тестовые среды. По идее той же схемы хотелось бы придерживаться и для "<луновых"> модулей, чем они собственно хуже?

\fastA Если действовать по аналогии с "<плюсовыми"> пакетами, то придется в require указывать и имя пакета, к которому относится нужный модуль. Это дает возможность сделать нормальную песочницу для разработки, к-ой безразлично, что установлено в системе. Кстати можно довести эту схему до абсолюта и интерпретатор Lua тоже собирать и использовать тот, что в песочнице, а не в системе.
Например, так работает (из-за особенностей паттерна пути в require не получится указать директорию "<..">):
\begin{lstlisting}[language=lua]
package.path="../?.lua;"..package.path
local fs = require("svn_wv_lua_scripts/filesystem");
print(fs.whatOs());
\end{lstlisting}

\fastQ Не приводит ли это нас к выводу, что нужно файлы тестов выкладывать в папку \path{_bin}?

\fastA Неа. Это ведь по сути исходники. Будем считать это за особенность разработки на скриптовых языках.


\fastQ Отставим пока в сторону вопрос о месторасположении. Как мне при разработке в MSVC или SciTE запустить один тестовый драйвер на выполнение?

\fastA Ну поскольку для студии можно установить лексер Lua, то можно предположить, что "<луновые"> скрипты включены прямо в проектник и правятся из студии. SciTE поддерживает Lua по-умолчанию. Следовательно запустить хочется тот тестовый драйвер, что сейчас открыт на редактирование, осталось только "<волшебную кнопку"> надавить. А перед сдачей проекта необходимо прогнать все его тесты, делаем активным проектник в дереве и жмем "<волшебную кнопку">. Ну это касалось чисто "<луновых"> пакетов, с ними по идее можно однообразно работать и в MSVC и в SciTE. А вот с "<плюсовыми"> так не получится, т.к. чтобы исключить какой-то TestSuite из компиляции, для студии подобные тесты написаны, их можно использовать. А при использовании чисто SciTe либо придется самостоятельно ковырять лежащий в папке пакета проектник, что ни есть хорошо, либо генерить Makefile, т.е. испоьзовать систему сборки, альтернативную той, что юзает MSVC. Смена системы сборки нам в ближайшем будущем не светит, поэтому нужно искать схему, которая подойдет в обоих случаях. Вспоминаем, что мы все-таки планировали фильтровать список тестов перед запуском, остается лишь определиться как мы определяем, что именно оставлять. Вариант с определением имен тестов путем парсинга исходников не кажется радужным, а вот получить информацию о файлах, будь то исходник, который мы сейчас ковыряем, или даже бинарник "<плюсового"> теста, путь к которому хранят недра проектного файла, то это более понятный и близкий вариант реализации. Отсюда делаем вывод, что скрипту, запускающему некий нужный нам набор тестов должен получить на вход список файлов (\path{*.t.lua}, \path{*.t.dll}) либо папок, в которых нужно поискать файлы с вышеуказанным расширением.


\fastQ В каких случаях тогда нужна фильтрация с использованием имени теста?

\fastA Похоже предложении предыдущего ответа не был учтен вариант запуска одного TestSuite-а, написанного на C++, при условии, что в тестовый драйвер пакета компилируются все имеющиеся в нем тесты. Было уже показано, как скриптами MSVC поправить это положение, но в ситуации испоьзования SciTE вопрос остается открытым. Как поступить? Ну как вариант можно установить курсор на имя нужного TestSuite-а, и вызвать сначала функцию, которая может определить слово под курсором (либо можно пользователю самому выделить имя, будет еще проще, правда скрипту, а не пользователю :-) ), и передать эту инфу скрипту. Делаем вывод, что скрипт может получать пути к файлам, к папкам и имена тестов, которые нужно запустить, выделив из общего списка. Имннт смысл распространить этот usecase (образец использования) и на MSVC, чтобы не путаться.


\fastQ Может имеет смысл попробовать предварительную ручную загрузку тех DLL, что могут понадобиться "<плюсовым"> тестовым драйверам для работы, ту же lua5.1.dll, cppunit.dll?

\fastA Они ведь используют и другие прикладные библиотеки, все не наподгружаешься, надо пробовать с изменением переменной среды PATH, либо все-таки сваливать бинарники "<плюсовых"> тестом в \path{_bin}, при условии, что скрипт сразу получит список тестовых DLL-лек.


\fastQ Кстати как он их получит из той же SciTE? Точнее такой вопрос: как получить полный список файлов \path{*.t.lua} и \path{*.t.dll}, относящихся к определенному пакету?

\fastA Все-таки тут без парсинга \path{*.vcproj}-файлов не обойтись, без этого не определить ни какие из \path{*.t.lua}-файлов относятся к данному проекту, ни определить под каким именем собираются бинарники тестовых драйверов. Значит располагать последние в пределах папки пакета не имеет смылса, при отсутствии плюсов, мы получаем больше мороки. Теперь насчет бинарников, достаточно уникальным будет имя DLL, состоящее из имени пакета, имени проектника пакета и названия конфигурации данного проектника, завершает все это расширение \path{*.t.dll}.

\fastA Стоит добавить, что это не относится к таким конфигурация проектного файла, как release, debug, test, а только к тем, в которых каким-то образом изменена функциональность прикладного кода. Тогда учитывая это придется, оставлять на изучение только те конфигурации, что содержат в развании слово test, в начале либо в конце, а узнавать, с каким именно имененм собирается тестовый драйвер -- из опции OutputFile.


\fastQ Получается, что вся информация, необходимая для запуска набора тестов получается из текущего редактора, либо из \path{*.vcproj}-файлов, т.е. никакого дополнительного файла настроек в пакете не нужно ?

\fastA Пока в это действительно нет необходимости. 


\fastQ Вроде бы не был прояснен вопрос с "<луновыми"> тестами к "<плюсовому"> коду, выставленному в Lua, он вроде не сильно вписывается в эту схему?

\fastA 


\fastQ А как же быть с теми тестами, что статически линкуют в себя тестируемую библиотеку, им-то для запуска DLL не нужны?

\fastA Нужны, например, cppunit.dll. Да и разносить такого такого типа тесты в другое место -- это просто рушить схему, причем в дальнейшем (а может быть просто в другой конфигурации того же проектника) эта библиотека будет собрана в виде динамически линкуемой библиотеки, так мы застрахуемся от излишних изменений в будущем.

\FAQend

%-------------------------------------------------------------------------
\subsection{w01487. Разобраться правильно ли мы вообще пишем тесты}
\FAQbegin


\fastQ Давайте не будем загонять все тесты к модели TestCase, где обязательно есть setUp(), tesrDown() и одна тестовая фукнция, т.к. могут быть тесты, для которых не нужны setUp(), tearDown()

\fastA Можно и так, только тогда на Lua придется несколько рамок теста делать? Неудобно, придется либо отдавать их написание на откуп в языки тестов, либо как-то изгаляться.


\fastQ У нас же Lua, можно просто проверять есть ли в TestCase-е нужная фукнция перед тем, как ее вызвать.

\fastA Согласен. Это можно сделать. 


\fastQ Но как тогда быть с TextFixture с несколькими TestCase-ами внутри?

\fastA Ну когда разработчик пишет такую конструкцию, то она ему кажется логически точной. Нужно ее просто привести к тому виду, который подходит рамке теста, т.е. к виду нескольких TestCase-ов.


% \fastQ 

% \fastA 

\FAQend

% \fastQ 

% \fastA 


% \fastQ 

% \fastA 


% \fastQ 

% \fastA 
