%--template 'shared_template.tex' --def title='Модульное тестирование' --def author='\we' --def today='???'
\newcommand{\reason}[1]{\footnote{\fbox{\parbox{\textwidth}{\textbf{Причина:}\\ #1}}}}
\newcommand{\FAQbegin}{}
\newcommand{\FAQend}{\medskip\hrule}
\newcommand{\fastQ}{\medskip\hrule\medskip{\red Q?}\quad}
\newcommand{\fastA}{{\blue A:}\quad}

%-------------------------------------------------------------------------------------------------------------
\section{Введение}
Модульное тестирование (unit test) "--- это тестирование отдельных функций, входящих в состав программы или программного комплекса. Модульное тестирование является одним из видов тестирования, выполняемых в рамках обеспечения надежности разрабатываемого ПО\footnote{Добавить ссылку на документ по надежности?}.

Для выполнения модульного тестирования требуется библиотека, упрощающая программирование и выполнение модульных тестов, кодовое наименование unit\_test, и документация\footnote{Уточнить состав и место} с рекомендациями по программированию тестов и регламентами тестирования.


%-------------------------------------------------------------------------------------------------------------
\section{Особенности модульного тестирования}

С технической точки зрения модульное тестирование заключается в выполнении тестируемых функций на некотором множестве исходных данных и сверке получаемых результатов с заранее известными с целью установить соответствие функции ее спецификации.

Таким образом, элементарный тест (test case) представляет собой программу, осуществляющую:
\begin{enumerate}
\item подготовку исходных данных;
\item выполнение тестируемой функции;
\item сверку полученных результатов с ожидаемыми;
\item освобождение использованных ресурсов;
\item вывод результата проверки.
\end{enumerate}

Программирование теста осуществляется в соответствии с образцами xUnit: проверка (Assertion), фикстура (Fixture), внешняя фикстура (External Fixture), тестовый метод (Test Method), тест исключительной ситуации (Exception Test). 

Для написания тестов используется тот же язык, что и для написания тестируемого кода.

Для убедительной проверки соответствия функции ее спецификации требуется выполнить набор тестов (test suite). Задача о выборе набора тестов для проведения модульного тестирования рассматривается в общем документе по тестированию\footnote{Добавить ссылку или перегруппировать}. 

Минимальной единицей исходного кода, которая включается в состав программы, выполняющей тесты, является минимальная физическая единица исходного кода "--- компонент (component, группа файлов с одинаковым именем \path{name.*}), содержащая набор функций, возможно объединеных в классы, которые составляют законченную часть логического дизайна.

Тестирование компонентов выполняется в рамках программирования пакета (Package), объединяющего группу логически и физически связанных компонентов в атомарную единицу процесса сборки.

ПК, состоящие из множества компонентов, требуют специальных способов организации процессов модульного тестирования. Для упрощения тестов, уменьшения их числа, быстрой локализации ошибки и легкой отладки используется восходящее модульное тестирование. Оно выполняется программистами в процессе создания исходного кода и подразумевает последовательное автоматизированное тестирование зависимых компонентов начиная с нижних уровней.

Следующие атрибуты тестов указывают на плохой дизайн прикладного кода:
\begin{enumerate}[--]
\item Длинный код инициализации. Если вы вынуждены написать сотни строк кода, создавая объекты для одного просто оператора ASSERT, значит что-то не так. Это означает, что ваши объекты слишком большие и их требуется разделить.
\item Дублирование кода инициализации. Если вы не можете быстро найти общее место для общего кода инициализации, это означает, что у вас слишком много объектов, которые слишком тесно взаимодействуют друг с другом.
\item Тесты выполняются слишком медленно. Если тесты TDD работают слишком медленно, значит, они не будут запускаться достаточно часто. Значит программист будет в течение некоторого времени работать, вообще не запуская тестов. Значит, когда он их все-таки запустит, скорее всего, многие из них не сработают. Иными словами, улучшив дизайн, вы можете увеличить скорость работы тестов.
\item Хрупкие тесты. Если ваши тесты неожиданно начинают ломаться в самых непредсказуемых местах, это означает, что одна часть разрабатываемого приложения непредсказуемым образом влияет на работу другой части. В этом случае необходимо улучшить дизайн таки образом, чтобы данный эффект исчез. Для этого можно либо устранить связь между частями приложения, либо объединить две части воедино.
\end{enumerate}

%-------------------------------------------------------------------------------------------------------------
\section{Варианты использования модульных тестов}

%-------------------------------------------------------------------------
\subsection{Разработка компонента}

Открываем компонент (для C++ -- это файлы \path{*.h}, \path{*.cpp} и \path{*.t.cpp}) в IDE (или подходящего редактора, который "<обвешан"> скриптами для работы с модульными тестами\footnote{Не ждите пока любимый только Вами, но не используемый другими разработчиками редактор будет соответствующим образом "<накачан"> скриптами, сделайте это сами. Список того, что будет поддерживаться однозначно -- это MS Visual Studio и SciTE.}). Подразумевается, что все используемые текущим компоненты уже протестированы.

Выбираем для проекта конфигурацию "<test">. Результатом сборки будет тестовый драйвер (Test Driver). При помощи него становиться возможным запуск содержащихся в нем тестов. Но поскольку мы вносим изменения в один компонент, то будет достаточным прогон только тестов, относящихся к нему.

Намечаем изменения, которые необходимо внести в компонент. Пишем в файле тестов (\path{*.t.cpp} -- для C++) новые тесты, проверяющие поведение кода согласно последней спецификации, либо подправляем уже имеющиеся. Затем производим сборку проекта и запуск тестов, для удобства эти два действия должны выполняться вспомогательным скриптом в одну атомарную операцию. Убеждаемся, что новые тесты провалились\footnote{А то вдруг и делать-то уже ничего не надо и код уже отвечает спецификации :-) }. Вносим изменения в основной код, опять запускаем тесты, смотрим какие из них завершились с ошибкой, исправляем код, опять прогоняем тесты и так до тех пор пока не будут проходить все тесты. 

%-------------------------------------------------------------------------
\subsection{Сдача кода в репозиторий}

Если делаете доставку пакета, то прогоните перед этим все его модульные тесты, если группу пакетов -- тесты всех пакетов, входящих в эту группу.

%-------------------------------------------------------------------------
\subsection{"<Night Build">}

На сервере автоматически выполняется сборка и модульное тестирование значительного количества компонентов (например, всех), находящихся в хранилище исходного кода. И потом с утречка программисты будут "<радоваться">, читая списки завалившихся ночью тестов. 

Можно подобную операцию выполнять дважды в сутки -- в обед и собственно ночью. А в качестве наказания за проваленную сборку можно назначать виновного отвечать за подобные полные сборки до тех пор, пока кто-нибудь еще не облажается.

%------------------------------------------------------
\section{Описание проблемы}

% \newcommand{\question}[1]{\fbox{\parbox{0.05\textwidth}{\huge\textbf{?}}}\fbox{\parbox{0.9\textwidth}{\quad #1}}}

% \newcommand{\question}[1]{%
%     \begin{tabular}{|c|c|}
%     \hline
%     &\\
%     \parbox[c][\totalheight][c]{1em}{\Huge\textbf{?}}&\parbox{.85\textwidth}{#1}\\
%     &\\
%     \hline
%     \end{tabular}
% }%

Есть требования, которым должен отвечать библиотека для работы с модульными тестами:
\begin{itemize}
\item Нужно уметь прогонять тесты для приложений на любом из используемых нами языков; 
\item Нужно уметь определять состав имеющихся тестов;
\item Нужно уметь запускать из всех тестов только определенные их наборы. Набор (коллекция) тестов может состоять как из одного теста, так и из всех тестов сразу;
\item Нужно уметь производить эти запуски удаленно, в несколько параллельных запусков (от разных пользователей), с ведением централизованных логов, с сохранением результатов в централизованную базу знаний\footnote{для последующего анализа менеджером проекта} и т.п.
\item Нужно уметь "<публиковать"> результаты тестов на обозрение разработчиков;
\item Нужно уметь прогонять тесты не только для наших проектов, но и для внешних\footnote{Конечно, обвешивание тестами готового проекта чрезвычайно сложно, но иногда может и понадобиться};
\item Нужно стремиться к минимизации времени реакции на запуск тестов. Весь прогон тестов должен быть настолько быстрым, что его было бы комфортно запускать разработчику как можно чаще;
\item Нужно уметь запускать всякие "<NightBuild">-ы полностью в автоматическом режиме, по расписанию и т.д.
\item Нужно уметь интегрировать управление запуском тестов в используемые IDE.
\end{itemize}

Кроме читабельных сообщений в output-е необходимы данные, на которые мог бы опираться скрипт выполняемый без участия человека. Т.е. в результате прогона теста скрипт должен знать о кол-ве успешних и кол-ве провалившихся тестов, их имена и сообщения об ошибках. Крах одного из тестом может означать остановку компиляции и запустка тестов всех пакетов, зависящих от того, чей тест грохнулся\footnote{Выяснение зависимостей между пакетами -- это другая задачка, просто смежная, в "<Large Scale">, в приложении С должно быть краткое описание этого процесса}. 

При проектировании решения надо отталкиваться от следующих предпосылок:
\begin{itemize}
\item Движок для запуска тестов нужно писать на Lua;
\item Пока при разработке из языков программирования мы будем использовать Lua и C/C++;
\item Придется уметь работать с такими IDE как MS Visual Studio и SciTE;
\item Всякие удаленные сборки будут запускаться с использованием LIWSI;
\item Переносимость приветствуется;
\end{itemize}

Создание интерфейса для Lua приследует одну мегацель -- это автоматизированный процесс восходящего регрессионного тестирования всего кода, который мы успели (и еще успеем) наколотить. В этот интерфейс должны входить такие функции, которых хватило бы на реализацию веб интерфеса, позволяющего разработчику несколькими щелчками мыши запускать тестовые модули только что закоммиченного пакета -- прям с пылу с жару новые фичи -- и всех пакетов, от которых он зависит (ну или вообще всех имеющихся), чтобы можно было лелеять достаточную надежду на то, что внесенные изменения не приводят код в инвалидное состояние. Джоэл Спольки предлагал повинности для таких программистов в виде обязанности выполнять регулярные сборки кода и дистрибутивов, пока кто-нибудь другой не сделает такой же косяк.

\pagebreak
%-------------------------------------------------------------------------------------------------------------
\section{Особенности реализации}

%-----------------------------------------------------
\subsection{Cхема расположения файлов в рабочей копии}

\begin{figure}[htbp]
\centering
\psset{mcol=l,rowsep=0.5ex,colsep=0em,nodesep=5pt,arm=0.5em,angleA=270,angleB=180}
\begin{psmatrix}
& \path{..}   \\ 
& \path{_bin} \\
& & \path{lua5.1.exe} \\
& & \path{lua5.1.dll} \\
& & \path{cppunit.dll} \\
& & \path{package1.dll} \\
& & \path{package1.t.dll} \\
& & \path{package1_demo.t.dll} \\
& \path{_lib} \\
& & \path{package1_demo.lib} \\
& & \path{package2.lib} \\
& \path{afl}    \\
& & \path{exec_test.lua}    \\
& & \path{test_runner.lua}  \\
& & \path{test.h}           \\
& \path{lua}   \\
& & \path{lua.h}      \\
& & \path{lualib.h}      \\
& & \path{luaxlib.h}      \\
& \path{package1}   \\
& & \path{_misc}      \\
& & & \path{*.sqlite}      \\
& & & \path{*.txt}      \\
& & \path{*.h}      \\
& & \path{*.cpp}    \\
& & \path{*.t.cpp}  \\
& & \path{*.lua}    \\
& & \path{*.t.lua}  \\
& & \path{exec_test.lua}    \\
& \path{package2}   \\
& & \path{*.h}      \\
& & \path{*.lua}    \\
\ncangle{2,2}{3,3}
\ncangle{4,2}{5,3} \ncangle{4,2}{6,3} \ncangle{4,2}{7,3} \ncangle{4,2}{8,3} \ncangle{4,2}{9,3}
\end{psmatrix}
%\caption{Тесты в рабочей копии} \label{fig:general_guide_environment_tests_at_working_copy}
\end{figure}

Пакеты лежат в папках одного уровня вложенности. Файлы прикладного исходного кода пакета и тестов к нему на C++ и на Lua находятся в папке данного пакета. Если пакет был распакован в рабочую копию из архива с пресобранными бинарниками, то скорее всего в папке пакета будут находиться только его заголовочные файлы.

Пакет \path{afl} обязателен для использования модульных тестов.

В папке \path{_bin} лежат собранные динамические библиотеки (\path{*.dll}, \path{*.so}) и исполняемые модули (\path{*.exe}), чтобы последние использовали библиотеки собранные из исходного кода данной рабочей копии. В папку \path{_lib} складываются собранные статические библиотеки. PDB-файлы лежат в тех же папках, что и бинарники, к которым они относятся.

Иногда для тестов нужны вспомогательные файлы (БД, бинарные и текстовые файлы, образы виртуальных машин и пр.), они лежат в отдельной подпапке пакета с именем \path{_misc}. Их наличие или отсутствие -- лично дело разработчика пакета.

"<Плюсовый"> тестовый драйвер собирается в динамически загружаемую библиотеку с именем \path{*.t.dll} или \path{*.t.so} в папку \path{_bin}. Тестовый драйвер на Lua одновременно является и файлом исходного кода, поэтому находится в папке пакета.

%-----------------------------------------------------
\subsection{Составные части}

Движок запускалки тестов (TestRunner) состоит из трех основных частей:
\begin{itemize}
\item cpp\_unit, код, позволяющий писать модульные тесты на C++
\item lua\_unit, код, позволяющий писать модульные тесты на Lua
\item test\_runner, "<луновый"> код, позволяющий загружать тестовые драйверы, собирать все TestCase-ы в один список, запускать тесты на выполнение, получать и распространять сообщения о ходе выполнения тестов.
\end{itemize}

cpp\_unit и lua\_unit по архитектуре аналогичны, просто написаны на разных языках. Они содержат ту функциональность, что не получиться вынести в test\_runner по причине языковых особенностей, а именно:
\begin{itemize}
\item макросы проверки, обеспечивающие самопроверяемость тестов, они уникальны для каждого языка из-за типов данных переменных, которые проходят проверку;
\item механизм создания объектов TestCase-ов и их регистрация в реестре тестов;
\item реализация синтаксиса написания тестов;
\item реализация защищенного вызова фукнции с кодом возврата и сообщением о возникщей проблеме.
\end{itemize}

В тестовом драйвере на C++ сбор TestCase-ов из всех файлов \path{*.t.cpp} производится за счет создания глобальных объектов шаблонных классов-регистраторов, к-ые создают в своем конструкторе статический объект конкретного класса, производного от TestCase или TestSuite, и регистрируют их в общем реестре "<плюсовых"> тестов (TestRegistry). 

В тестовом драйвере на Lua регистрация отдельных тестов в реестре "<луновых"> тестов реализуется за счет использования функций TEST\_SUITE, TEST\_CASE, TEST\_CASE\_EX при написании тестов.

Одна из главных задач test\_runner-а -- это при помощи выставленных в Lua функций тестовых драйверов cpp\_unit и lua\_unit загрузить последние и получить от них "<луновые"> объекты с интерфейсом TestCase-а, т.е. имеющими фукнции setUp, test и tearDown и поле name\_. Ненужные тесты отфильтровываются (при этом из памяти объекты тестов не удаляются), а остальные проходят "<рамку теста">.

"<Рамка теста"> представляет из себя последовательный вызов фукнций \verb|setUp()|, \verb|test()| и \verb|tearDown()|, плюс в нужные моменты TestObserver-у посылаются сообщения о тестах (какой тест начал выполняться, как завершился, какой завершился и т.п.). Функция \verb|test()| не будет вызвана, если завершилась с ошибкой \verb|setUp()|. Если все-таки \verb|setUp()| выполнилась успешно, но будет вызвана \verb|test()| и обязательно -- \verb|tearDown()|. С помощью фукнций \verb|setUp()| и \verb|tearDown()| Вы можете инициализировать тестовую среду до выполнения теста и привести систему в исходное состояние после выполнения теста, чтобы не  мешать выполнению других тестов.

"<Плюсовые"> тестовые драйверы загружаются следующим образом. Во-первых, в память загружается динамическая библиотека самого cpp\_unit-а:\\ \verb|local getTestList = package.loadlib("../_bin/cppunit."..dllExt, "getTestList")|,\\ затем тестовые драйверы: \\ \verb|package.loadlib("../_bin/*.t."..dllExt, "")|.\\ Все тестовые драйверы используют объекты и фукнции, экспортируемые динамической библиотекой cpp\_unit-а, поэтому загруженные в текущий процесс динамические библиотеки тестовых драйверов имеют общие глобальные объекты, а следовательно пользуются одним реестром "<плюсовых"> тестов, в который вновь подгружаемый тестовый драйвер старательно складывает все свои тесты во время инициализации своих глобальных объектов.

"<Луновые"> тестовые драйверы грузятся банальнейшим образом -- при помощи фукнции dofile.

Т.к. подавляющий объем кода находится в test\_runner и он "<луновый">, то это упрощает процесс разработки и поддержки проекта за счет большей скорости разработки на скриптовом языке. Особенно это скажется при написании сложных TestListener-ов, коих нам понадобиться несколько типов, выдающих, например, полученные сообщения в определенном формате (txt, html, http-запрос) и на определенный приемник (консольный вывод, файл, syslogd, веб-сервер, Jabber Client). Для того, чтобы можно было на некотором количестве тестов запускать несколько наборов тестов без перезапуска, либо порождения отдльного процесса, нужно, чтобы при фильтрации списка запускаемых TestCase-ов сами объекты этих TestCase-ов не удалялись из памяти.

%-----------------------------------------------------
\subsection{Основные классы}

\begin{itemize}
\item Test -- абстрактный базовый класс тестов, содержит виртуальную фукнцию test()
\item TestFixture -- базовый класс, содержит виртуальные фукнции setUp() и tearDown()
\item TestCase -- базовый класс тестов, производный от Test и TestFixture содержит пустые setUp() и tearDown(). Чтобы в тесте иметь возможность использовать некоторые разделяемые ресурсы, то необходимо сначала создать "<живую"> TestFixture и унаследовать от нее конкретный класс TestCase-а.
\item TestSuite -- набор тестов, содержит список TestCase-ов
\item TestRegistry -- реестр тестов
\item TestObserver -- объект, получающий сообщения по ходу выполнения тестов и рассылающий их всем подписавшимся TestListener-ам
\item TestListener -- выводит сообщения о тестах туда, где их будет смотреть разработчик
\item TextTestProgressListener -- выводит сообщения о тестах в output в виде простого текста
\end{itemize}

%-----------------------------------------------------
\subsection{Макросы проверки}

Для тестов на C++ доступны следующие макросы:
\begin{itemize}
\item ASSERT(condition)
\item ASSERT\_EQUAL(expected, actual)
\item ASSERT\_DOUBLES\_EQUAL(expected, actual, delta)
\item ASSERT\_THROW(expression, exceptionType)
\item ASSERT\_NO\_THROW(expression)
\end{itemize}

а для тестов на Lua:
\begin{itemize}
\item ASSERT(assertion)
\item ASSERT\_TRUE(actual)
\item ASSERT\_FALSE(actual)
\item ASSERT\_THROW(functionForRun, ...)
\item ASSERT\_NO\_THROW(functionForRun, ...)
\item ASSERT\_EQUAL(expected, actual)
\item ASSERT\_NOT\_EQUAL(expected, actual)
\item ASSERT\_NIL(variable)
\item ASSERT\_BOOLEAN(variable)
\item ASSERT\_NUMBER(variable)
\item ASSERT\_STRING(variable)
\item ASSERT\_TABLE(variable)
\item ASSERT\_FUNCTION(variable)
\item ASSERT\_THREAD(variable)
\item ASSERT\_USERDATA(variable)
\item ASSERT\_NOT\_NIL(variable)
\item ASSERT\_NOT\_BOOLEAN(variable)
\item ASSERT\_NOT\_NUMBER(variable)
\item ASSERT\_NOT\_STRING(variable)
\item ASSERT\_NOT\_TABLE(variable)
\item ASSERT\_NOT\_FUNCTION(variable)
\item ASSERT\_NOT\_THREAD(variable)
\item ASSERT\_NOT\_USERDATA(variable)
\end{itemize}

%-------------------------------------------------------------------------
\subsection{Подготовка тестов на уровне компонента}

Прежде чем писать тесты для какого-нибудь компонента необходимо проверить, что текущая конфигурация проектника -- "<test">, в которой определена директива препроцессора TS\_TEST.

Размещать тестовые классы следует в файлах с окончанием \path{*.t.*} в имени. В начале этих файлов нужно размещать документацию по компоненту, к которому они относятся, а затем уже собственно модульные тесты.

Сторожевое условие
\begin{lstlisting}[style=cpp]
#if defined(TS_TEST)
#include "..\afl\test.h"
// ... content of *.t.cpp file ...
#endif // defined(TS_TEST)
\end{lstlisting}
необходимо для того, чтобы при сборке релиза пакета в него не попало содержимое тестов.

В тестовых функциях можно использовать макросы для проверки соответствия полученных результатов с ожидаемыми.

\begin{lstlisting}[language=lua]
//////////////////////// C++ tests //////////////////////////////
// Опредение новой тестовой фикстуры -- класса, производного от TestFixture
TEST_FIXTURE(SetUpCallCheckFixture)
{
    // функция setUp, к-ая будет выполняться ДО каждого из TestCase-ов,
    // наследующихся от данного класса
    SETUP
	{
		setUpCall_ = true;
	}

    // функция tearDown, к-ая будет выполняться ПОСЛЕ каждого из TestCase-ов,
    // наследующихся от данного класса
    TEARDOWN
	{
		setUpCall_ = false;
	}
protected:
	bool setUpCall_;
};

// Опредение нового "набора тестов" - класса, наследующегося от TestSuite
TEST_SUITE(SampleTestSuite)
{
    // Определение нового простого теста - класса, производного от TestCase
	TEST_CASE(testEqualAssert)
		ASSERT_EQUAL(1, 1);
		ASSERT_EQUAL(0, 0);
		ASSERT_EQUAL(-1, -1);
	TEST_CASE_END

    // Определение нового теста - класса, производного от TestCase и фикстуры SampleFixture
    // Такой тест может использовать данные, содержащиеся в SampleFixture
	TEST_CASE_EX(testCheckSetUpCall, SetUpCallCheckFixture)
		ASSERT(setUpCall_);
	TEST_CASE_END
};
\end{lstlisting}
\clearpage
\begin{lstlisting}[language=lua]
-------------------- Lua tests ----------------------------
-- Опредение новой тестовой фикстуры - класса, производного от TestFixture
TEST_FIXTURE("SampleFixture")
{
    -- функция setUp, к-ая будет выполняться ДО каждого из TestCase-ов,
    -- наследующихся от данного класса
    setUp = function(self)
        self.q_.initialize();
    end
    ;
    -- функция tearDown, к-ая будет выполняться ПОСЛЕ каждого из TestCase-ов,
    -- наследующихся от данного класса
    tearDown = function(self)
        self.q_.release();
    end
    ;
    -- используемые тестами ресурсы
    q_ = 
    {
        initialize = function() end;
        release = function() end;
        add = 
            function(self, value)
                table.insert(self.list, value);
                if self.list[#self.list] then
                    return true;
                end
            end;
        list = {};
    };
};

-- Опредение нового "набора тестов" - класса, наследующегося от TestSuite
TEST_SUITE("SampleTestSuite")
{
    -- Определение нового простого теста - класса, производного от TestCase
    TEST_CASE{"simpleTest", function(self)
        local q = 2;
        ASSERT_EQUAL(4, q + 2);
    end
    };
    -- Определение нового теста -- класса, производного от TestCase и фикстуры SampleFixture
    -- Такой тест может использовать данные, содержащиеся в SampleFixture
    TEST_CASE_EX{"addTest", "SampleFixture", function(self)
        ASSERT_TRUE(self.q_:add(""));
    end
    };
};
\end{lstlisting}
\clearpage

%-----------------------------------------------------
\subsection{Скрипты для IDE}

Для SciTe нужно добавить в файл пльзовательских настроек:
\begin{verbatim}
file.patterns.tlua=*.t.lua

# Run tests, using TestRunner
command.build.$(file.patterns.tlua)=lua5.1.exe -e "\
package.path='./?.lua;./?/init.lua;../?.lua;../?/init.lua;'..package.path;\
package.cpath='../_bin/?.dll;../_bin/?.so' .. package.cpath;\
local testRunner = require('afl.test_runner');\
local dllExt = testRunner.isWin() and 'dll' or 'so';\
testRunner.loadTestDrivers\
{\
	'$(FileNameExt)',\
};\
local testObserver = testRunner.TestObserver:new();\
testObserver:addTestListener(testRunner.SciteTextTestProgressListener:new());\
testRunner.runAllTestCases(testObserver);"
\end{verbatim}

А в конфигурацию "<test"> проектника нужно в качестве Post-Build Event поставить команду (прописывать ее одной строкой):
\begin{verbatim}
lua5.1.exe -e "package.path='./?.lua;
./?/init.lua;../?.lua;../?/init.lua;'.. package.path;
package.cpath='../_bin/?.dll;'.. package.cpath;
local testRunner = require('afl.test_runner');
testRunner.loadTestDrivers{'../_bin/$(TargetFileName)'};
local testObserver = testRunner.TestObserver:new();
testObserver:addTestListener(testRunner.TextTestProgressListener:new());
testRunner.runAllTestCases(testObserver);"
\end{verbatim}

%-------------------------------------------------------------------------
% \subsection{Выполнение тестов на уровне компонента}
% \begin{figure}[h !t]
% \centering
% \includegraphics[scale=0.7]{cppunit_exception_classes.eps}
% \caption{Иерархия классов исключений для тестов}
% \end{figure}
% \begin{figure}[h !t]
% \centering
% \includegraphics[scale=0.7]{cppunit_test_suite_classes.eps}
% \end{figure}
% \begin{figure}[h !t]
% \centering
% \includegraphics[scale=0.7]{cppunit_test_result_classes.eps}
% \end{figure}
% \begin{figure}[h !t]
% \centering
% \includegraphics[scale=1.0]{cppunit_seq_diag.eps}
% \caption{Успешное выполнение одного теста}\label{fig:module_test_successful_execution}
% \end{figure}    
% \clearpage
% \pagebreak

%-----------------------------------------------------
\subsection{Неразрешенные вопросы}

\FAQbegin


\fastQ Какие TestListener-ы нужны?

\fastA \ldots


\fastQ Схема фильтрации списка запускаемых тестов пока не продумана, поэтому по ней пока не сделано серьезных наработок. 

\fastA Основная мысль в том, чтобы выставлять флаги разрешения выполнения в реестре тестов самого test\_runner-а. Однако, надо отметить, что поскольку тесты содержаться в файлах ("<луновые"> в \path{*.t.lua}, "<плюсовые"> в \path{*.t.dll}), то фильтрацией списка запускаемых тестов можно управлять на двух уровнях: физическом (файлами), логическом (списками уже загруженный тестов).


\fastQ Первоначально задумывалось оставить возможность запускать чисто "<плюсовые"> тесты, используя лишь "<плюсовый"> код, и аналогично для "<луновой"> части. Имеет ли смысл это реализовывать?

\fastA \ldots


\fastQ Сейчас класс TestCase реализован и на Lua и на C++, оправдано ли такое дублирование?

\fastA Если мы оставим только "<плюсовую"> реализацию, то не сможем тогда запускать "<луновые"> тесты без использования "<плюсового"> кода, теряется независимость частей движка.


\fastQ Необходимо ли сменить имя класса TestCase из-за измененной функциональности по сравнению с классической моделью модульных тестов xUnit-а?

\fastA Вероятнее всего. Название нужно придумать.


\fastQ Принадлежность TestCase-а к какому-либо TestSuite-у отражать только в названии?

\fastA Это самый простой способ. Если в общем реестре тестов начать делать иерархии, то это должно быть оправдано, можно опять к этому вернуться, когда более подробно будут проработаны требуемые критерии фильтрации списка выполняемые тестов.


\fastQ А если мы загружаем тестовые модули, собранные для разных версий cppunit, у к-ых одинаковые интерфейсные функции?

\fastA Главное - это чтобы не менялся интерфейс и поведение класса TestCase, а остальное не важно. А если будут отличаться, то мы упадем и все ("<мертвые программы не лгут">). Хотя могут быть сложности с выявлением ошибки подобного типа.


\fastQ В итоге получилось, что в Lua из C++ выставлено только TestCase и фукнция по предоставлению их списка?

\fastA Больше пока ничего выставлять не надо, получается обходиться этим. 


\fastQ Если рассмотреть гипотетическую ситуацию, что у нас не два, три и более языков с модульными тестами, которые необходимо запускать однотипным образом, применяя принцип полиморфизма?

\fastA Ну ситуация-то не такая уж и гипотетическая, ведь можно считать другим языком и язык скриптов, SQL, которыми мы также пользуемся, и еще самые низкоуровневые библиотеки можно писать в рамках ANSI C, что добавляет еще один язык. А что касается о стратегии "<прикинуться как другие">, то можно действовать так: сами языки наверняка имеют C API, нужно просто используя его написать и выставить в Lua тот же набор объектов и фукнций, что и для C++. Хотя такого рода "<заворачивание"> используя и Lua. Главное при этом помнить, что модульные тесты обычно пишутся на том же языке, что и основной код. Если от этого приходиться отказываться, то реализация пошла не тем путем.


\fastQ Это все конечно неплохо выглядит, но при этом собственно файлы с тестами получаются пассивными, их не получится использовать независимо, не прибегая к "<запускалке">

\fastA Ну вариант stanalone теста хорош, когда ковыряешься конкретно в нем и запускаешь его в гордом одиночесве. Но когда необходимо запустить десятки и более тестов и получить по ним СУММАРНУЮ статистику, то ничего не выйдет хорошего. Можно и с придуманной схемой эмулировать такое поведение используя фильтрацию списка запускаемых тестов, ну и еще обвешать в достаточной мере скриптами IDE. Главное ведь не в том, насколько сложна система, а насколько ей удобно пользоваться. При правильном подходе пользователи и разницы-то не почувствуют. Лично у меня для файлов \path{*.t.lua}, к-ые, я считаю по-умолчанию, написаны под lunit, запускаются более заковыристой командой с выполнением предварительного кода, передаваемого Луне в параметре --e. Это самый простой пример.


\fastQ Ну допустим, сделали мы пакет полезного кода, пару модулей на Lua, несколько на C++, и естесственно тесты к ним. Что еще должно находиться в составе пакета (а может быть и нет), чтобы эти тесты можно было прогонять?

\fastA Было бы заманчиво сделать пакет независимым в плане: "<загрузил и все есть">, но это как с компилятором, штука отдельная от собственно кода. Так и запускалка, она ведь может, по-идее использовать кучу сторонних модулей и таскать их с каждым пакетом неразумно. Надо просто принять, что пакет можно "<откомпилировать">, а можно "<протестировать">.


\fastQ Подойдет ли данная модель в случае, когда у нас хостовым приложением является не сам Lua интерпретатор, а какое-нибудь из разработываемых нами приложений?

\fastA Т.е. нужно предусмотреть возможность подмены дефолтового интерпретатора другим. Проблема может быть в том, что у нас, скорее всего, в нашем хостовом приложении будет жестко ограничен набор используемых модулей, урезаны даже стандартные библиотеки и т.п., и оставшегося может просто не хватить для работы движка "<запускалки тестов">. Т.к. еще неизвестно как это будет выглядеть в действительности, то сейчас и рассуждать особо не стоит, как и совсем забывать об этом.
\FAQend

%-------------------------------------------------------------------------
\subsection{w01481. Подобрать схему запуска тестов при работе с MSVC и SciTE}

\FAQbegin
\fastQ Процесс сборки "<плюсовой"> части движка (Cppunit ??)

\fastA Сам CppUnit, входит в состав afl, будет представлять из себя один модуль (см. пост выше), зависит от модулей, где реализованы Thunk и типы данных. Но собирать-то его необходимо в DLL-ку (см. пост выше, чтобы узнать причину), вряд ли весь afl будет использоваться тем же способом, следовательно под его сборку нужно завести отдельный проектник. Библиотеку импорта нужно складывать в \path{_lib}, саму DLL-ку -- в \path{_bin}, т.к. она нужна для тестов различных пакетов, и ее незачем дублировать для каждого. 


\fastQ Сколько "<плюсовых"> тестовых драйверов может быть сделано от одного пакета?

\fastA Наверное, столько же сколько есть проектников в этом пакете. Вопрос только в том, могут ли при этом одни и те же тесты войти в разные тестовые драйверы? По идее каждый из тестов полностью независим и не влияет на запуск других тестов, единственный минус от множественного запуска одного и того же теста -- потеря времени. 

\fastA Не совсем верно, т.к. в одном проектнике могут быть несколько конфигураций (допустим, они отличаются наличием или отсутствием некоторых макросов), считай, каждай имеет свой вариант кода, соответственно и свой набор тестов.


\fastQ Получается, что все тестовые драйверы лежат одной большой кучей, а нам каким-то образом нужно выцепить и запустить лишь несколько из них при разработке одного пакета?

\fastA Получается так. Причем, учитывая, что имя проектника может не совпадать с именем собираемой библиотеки, то их не получится брать в качестве опорной точки в поисках. Проще и надежнее будет в начале имени тестового драйвера указывать имя пакета. 


\fastQ Сейчас за счет использования заголовочных файлов "<плюсовые"> пакеты могут находить друг друга в пределах одной рабочей копии, можно создавать локальные тестовые среды. По идее той же схемы хотелось бы придерживаться и для "<луновых"> модулей, чем они собственно хуже?

\fastA Если действовать по аналогии с "<плюсовыми"> пакетами, то придется в require указывать и имя пакета, к которому относится нужный модуль. Это дает возможность сделать нормальную песочницу для разработки, к-ой безразлично, что установлено в системе. Кстати можно довести эту схему до абсолюта и интерпретатор Lua тоже собирать и использовать тот, что в песочнице, а не в системе.
Например, так работает (из-за особенностей паттерна пути в require не получится указать директорию "<..">):
\begin{lstlisting}[language=lua]
package.path="../?.lua;"..package.path
local fs = require("svn_wv_lua_scripts/filesystem");
print(fs.whatOs());
\end{lstlisting}

\fastQ Не приводит ли это нас к выводу, что нужно файлы тестов выкладывать в папку \path{_bin}?

\fastA Неа. Это ведь по сути исходники. Будем считать это за особенность разработки на скриптовых языках.


\fastQ Отставим пока в сторону вопрос о месторасположении. Как мне при разработке в MSVC или SciTE запустить один тестовый драйвер на выполнение?

\fastA Ну поскольку для студии можно установить лексер Lua, то можно предположить, что "<луновые"> скрипты включены прямо в проектник и правятся из студии. SciTE поддерживает Lua по-умолчанию. Следовательно запустить хочется тот тестовый драйвер, что сейчас открыт на редактирование, осталось только "<волшебную кнопку"> надавить. А перед сдачей проекта необходимо прогнать все его тесты, делаем активным проектник в дереве и жмем "<волшебную кнопку">. Ну это касалось чисто "<луновых"> пакетов, с ними по идее можно однообразно работать и в MSVC и в SciTE. А вот с "<плюсовыми"> так не получится, т.к. чтобы исключить какой-то TestSuite из компиляции, для студии подобные тесты написаны, их можно использовать. А при использовании чисто SciTe либо придется самостоятельно ковырять лежащий в папке пакета проектник, что ни есть хорошо, либо генерить Makefile, т.е. испоьзовать систему сборки, альтернативную той, что юзает MSVC. Смена системы сборки нам в ближайшем будущем не светит, поэтому нужно искать схему, которая подойдет в обоих случаях. Вспоминаем, что мы все-таки планировали фильтровать список тестов перед запуском, остается лишь определиться как мы определяем, что именно оставлять. Вариант с определением имен тестов путем парсинга исходников не кажется радужным, а вот получить информацию о файлах, будь то исходник, который мы сейчас ковыряем, или даже бинарник "<плюсового"> теста, путь к которому хранят недра проектного файла, то это более понятный и близкий вариант реализации. Отсюда делаем вывод, что скрипту, запускающему некий нужный нам набор тестов должен получить на вход список файлов (\path{*.t.lua}, \path{*.t.dll}) либо папок, в которых нужно поискать файлы с вышеуказанным расширением.


\fastQ В каких случаях тогда нужна фильтрация с использованием имени теста?

\fastA Похоже предложении предыдущего ответа не был учтен вариант запуска одного TestSuite-а, написанного на C++, при условии, что в тестовый драйвер пакета компилируются все имеющиеся в нем тесты. Было уже показано, как скриптами MSVC поправить это положение, но в ситуации испоьзования SciTE вопрос остается открытым. Как поступить? Ну как вариант можно установить курсор на имя нужного TestSuite-а, и вызвать сначала функцию, которая может определить слово под курсором (либо можно пользователю самому выделить имя, будет еще проще, правда скрипту, а не пользователю :-) ), и передать эту инфу скрипту. Делаем вывод, что скрипт может получать пути к файлам, к папкам и имена тестов, которые нужно запустить, выделив из общего списка. Имннт смысл распространить этот usecase (образец использования) и на MSVC, чтобы не путаться.


\fastQ Может имеет смысл попробовать предварительную ручную загрузку тех DLL, что могут понадобиться "<плюсовым"> тестовым драйверам для работы, ту же lua5.1.dll, cppunit.dll?

\fastA Они ведь используют и другие прикладные библиотеки, все не наподгружаешься, надо пробовать с изменением переменной среды PATH, либо все-таки сваливать бинарники "<плюсовых"> тестом в \path{_bin}, при условии, что скрипт сразу получит список тестовых DLL-лек.


\fastQ Кстати как он их получит из той же SciTE? Точнее такой вопрос: как получить полный список файлов \path{*.t.lua} и \path{*.t.dll}, относящихся к определенному пакету?

\fastA Все-таки тут без парсинга \path{*.vcproj}-файлов не обойтись, без этого не определить ни какие из \path{*.t.lua}-файлов относятся к данному проекту, ни определить под каким именем собираются бинарники тестовых драйверов. Значит располагать последние в пределах папки пакета не имеет смылса, при отсутствии плюсов, мы получаем больше мороки. Теперь насчет бинарников, достаточно уникальным будет имя DLL, состоящее из имени пакета, имени проектника пакета и названия конфигурации данного проектника, завершает все это расширение \path{*.t.dll}.

\fastA Стоит добавить, что это не относится к таким конфигурация проектного файла, как release, debug, test, а только к тем, в которых каким-то образом изменена функциональность прикладного кода. Тогда учитывая это придется, оставлять на изучение только те конфигурации, что содержат в развании слово test, в начале либо в конце, а узнавать, с каким именно имененм собирается тестовый драйвер -- из опции OutputFile.


\fastQ Получается, что вся информация, необходимая для запуска набора тестов получается из текущего редактора, либо из \path{*.vcproj}-файлов, т.е. никакого дополнительного файла настроек в пакете не нужно ?

\fastA Пока в это действительно нет необходимости. 


\fastQ Вроде бы не был прояснен вопрос с "<луновыми"> тестами к "<плюсовому"> коду, выставленному в Lua, он вроде не сильно вписывается в эту схему?

\fastA 


\fastQ А как же быть с теми тестами, что статически линкуют в себя тестируемую библиотеку, им-то для запуска DLL не нужны?

\fastA Нужны, например, cppunit.dll. Да и разносить такого такого типа тесты в другое место -- это просто рушить схему, причем в дальнейшем (а может быть просто в другой конфигурации того же проектника) эта библиотека будет собрана в виде динамически линкуемой библиотеки, так мы застрахуемся от излишних изменений в будущем.

\FAQend

%-------------------------------------------------------------------------
\subsection{w01487. Разобраться правильно ли мы вообще пишем тесты}
\FAQbegin


\fastQ Давайте не будем загонять все тесты к модели TestCase, где обязательно есть setUp(), tesrDown() и одна тестовая фукнция, т.к. могут быть тесты, для которых не нужны setUp(), tearDown()

\fastA Можно и так, только тогда на Lua придется несколько рамок теста делать? Неудобно, придется либо отдавать их написание на откуп в языки тестов, либо как-то изгаляться.


\fastQ У нас же Lua, можно просто проверять есть ли в TestCase-е нужная фукнция перед тем, как ее вызвать.

\fastA Согласен. Это можно сделать. 


\fastQ Но как тогда быть с TextFixture с несколькими TestCase-ами внутри?

\fastA Ну когда разработчик пишет такую конструкцию, то она ему кажется логически точной. Нужно ее просто привести к тому виду, который подходит рамке теста, т.е. к виду нескольких TestCase-ов.


% \fastQ 

% \fastA 

\FAQend

% \fastQ 

% \fastA 


% \fastQ 

% \fastA 


% \fastQ 

% \fastA 
