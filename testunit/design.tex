%--template 'shared_template.tex' --def title='Модульное тестирование' --def author='\we' --def today='???'
\newcommand{\framed}[1]{\fbox{\parbox{\textwidth}{#1}}}
\newcommand{\reason}[1]{\footnote{\framed{\textbf{Причина:}\\ #1}}}
\newcommand{\divblock}[1]{$ $\\}
\newcommand{\testunit}{testunit}

\newcounter{faqCount}
\setcounter{faqCount}{0}
\newcommand{\FAQbegin}{}
\newcommand{\FAQend}{\medskip\hrule}
\newcommand{\fastQ}{\addtocounter{faqCount}{1}\medskip\hrule\medskip{\red Q\arabic{faqCount}?}\quad}
\newcommand{\fastA}{{\blue A:}\quad}

%-------------------------------------------------------------------------------------------------------------
\section{Список терминов и сокращений}

\begin{tabulary}{\textwidth}{p{\textwidth}}
{\bfseries <<Движок>>/библиотека модульных тестов (Test Unit Engine)} -- вся библиотека testunit как отдельный пакет \\
{\bfseries Контейнер тестов (Test Container)} -- файлы, содержащие набор тестов в некотором формате (\path{*.t.dll}, бинарный формат в случае тестов на C++ (C++ Test Container) и \path{*.t.lua}, текстовый формат в случае тестов на Lua (Lua Test Container)\\
{\bfseries Тестовый драйвер (Test Driver)} -- это набор тестов и сценарий запуска для содержащихся в них тестов \\
{\bfseries <<Запускалка>> тестов (Test Runner)} --  та часть функциональности библиотеки testunit, которая отвечает за поиск, загрузку тестовых контейнеров, получение из них списков тестов, их запуск и публикация результатов прогона тестов \\
{\bfseries <<Движок>> тестов для определенного языка программирования (Programming Language Test Engine)} -- та часть функциональности библиотеки testunit, которая отвечает за синтаксис тестов, набор тестовых проверок, составление коллекции тестов в Test Container-е и защищенный вызов тестовых функций для тестов, написанных на определенном языке программирования. На данный момент реализованы два таких <<движка>>: C++ Test Engine и Lua Test Engine \\
{\bfseries } Тест кейс (контрольный пример) (Test Case) -- один отдельный тест \\
{\bfseries } Набор тестов (Test Suite) -- набор тест кейсов \\
\end{tabulary}

Есть требования, которым должен отвечать библиотека для работы с модульными тестами:
\begin{itemize}
\item Нужно уметь прогонять тесты для приложений на любом из используемых нами языков; 
\item Нужно уметь определять состав имеющихся тестов;
\item Нужно уметь запускать из всех тестов только определенные их наборы. Набор (коллекция) тестов может состоять как из одного теста, так и из всех тестов сразу;
\item Нужно уметь производить эти запуски удаленно, в несколько параллельных запусков (от разных пользователей), с ведением централизованных логов, с сохранением результатов в централизованную базу знаний\footnote{для последующего анализа менеджером проекта} и т.п.
\item Нужно уметь "<публиковать"> результаты тестов на обозрение разработчиков;
\item Нужно уметь прогонять тесты не только для наших проектов, но и для внешних\footnote{Конечно, обвешивание тестами готового проекта чрезвычайно сложно, но иногда может и понадобиться};
\item Нужно стремиться к минимизации времени реакции на запуск тестов. Весь прогон тестов должен быть настолько быстрым, что его было бы комфортно запускать разработчику как можно чаще;
\item Нужно уметь запускать всякие "<NightBuild">-ы полностью в автоматическом режиме, по расписанию и т.д.
\item Нужно уметь интегрировать управление запуском тестов в используемые IDE.
\end{itemize}

Кроме читабельных сообщений в output-е необходимы данные, на которые мог бы опираться скрипт выполняемый без участия человека. Т.е. в результате прогона теста скрипт должен знать о количестве успешных и количестве провалившихся тестов, их имена и сообщения об ошибках. Крах одного из тестом может означать остановку компиляции и запуска тестов всех пакетов, зависящих от того, чей тест грохнулся\footnote{Выяснение зависимостей между пакетами -- это другая задачка, просто смежная, в "<Large Scale">, в приложении С должно быть краткое описание этого процесса}. 

%-------------------------------------------------------------------------------------------------------------
\section{Требования к библиотеке}

При проектировании решения надо отталкиваться от следующих предпосылок:
\begin{itemize}
\item Движок для запуска тестов нужно писать на Lua\reason{Цель -- это автоматизированный процесс восходящего регрессионного тестирования всего кода, который мы успели (и еще успеем) наколотить. Причем выставленного интерфейса должно хватать на реализацию веб-интерефейса, позволяющего разработчику несколькими щелчками мыши запускать тестовые модули только что доставленного пакета};
\item Пока при разработке из языков программирования мы будем использовать Lua и C/C++;
\item Придется уметь работать с такими IDE как MS Visual Studio и SciTE;
\item Всякие удаленные сборки будут запускаться с использованием сервера непрерывной интеграции;
\item Переносимость приветствуется;
\end{itemize}

%-------------------------------------------------------------------------------------------------------------
\section{Анализ предметной области}

Выделим семейство процессов разработки с использованием модульных тестов:
\begin{itemize}
\item разработка прикладного кода на C++ 
\item разработка прикладных кода на Lua
\item разработка кода С++, выставленного в Lua, и тесты на Lua к нему (гетерогенная разработка)
\end{itemize}

Общими для семейства являются:
\begin{itemize}
\item работаем в среде разработки
\item пишем тесты на языке разработки
\item запускаем тесты на выполнение
\end{itemize}

Разработка в стиле TDD или без него -- не важно, это положительная изменчивость.

Отрицательная изменчивость -- запуск тестов при помощи Hudson, он не разрабатывает, а только запускает тесты (прогон вне среды).

Использование генератора кода (либо чего-то другого) для создания оберток в Lua считаем выходящим за рамки данного анализа, и вообще плохим вариантом.

Разработка скриптов на Lua в рамках и для ГеПарта также выходит за рамки данного семейства, т.е. из разработчиков остаемся только мы, заказчики -- нет.

Для написания тестов используется тот же язык, что и для написания тестируемого кода.

% \newcommand{\question}[1]{\fbox{\parbox{0.05\textwidth}{\huge\textbf{?}}}\fbox{\parbox{0.9\textwidth}{\quad #1}}}

% \newcommand{\question}[1]{%
%     \begin{tabular}{|c|c|}
%     \hline
%     &\\
%     \parbox[c][\totalheight][c]{1em}{\Huge\textbf{?}}&\parbox{.85\textwidth}{#1}\\
%     &\\
%     \hline
%     \end{tabular}
% }%

\pagebreak
%-------------------------------------------------------------------------------------------------------------
\section{Особенности реализации}

%-----------------------------------------------------
\subsection{Cхема расположения файлов в рабочей копии}

\begin{figure}[htbp]
\centering
\psset{mcol=l,rowsep=0.5ex,colsep=0em,nodesep=5pt,arm=0.5em,angleA=270,angleB=180}
\begin{psmatrix}
& \path{..}   \\ 
& \path{_bin} \\
& & \path{lua5.1.exe} \\
& & \path{lua5.1.dll} \\
& & \path{cppunit.dll} \\
& & \path{package1.dll} \\
& & \path{package1.t.dll} \\
& \path{_lib} \\
& & \path{lua5.1.lib} \\
& & \path{package2.lib} \\
& \path{testunit}    \\
& & \path{test_runner.lua}  \\
& & \path{test_listeners.lua}  \\
& & \path{test.h}           \\
& \path{lua}   \\
& & \path{lua.h}      \\
& & \path{lualib.h}      \\
& & \path{luaxlib.h}      \\
& \path{package1}   \\
& & \path{_misc}      \\
& & & \path{*.sqlite}      \\
& & & \path{*.txt}      \\
& & \path{*.h}      \\
& & \path{*.cpp}    \\
& & \path{*.t.cpp}  \\
& & \path{*.lua}    \\
& & \path{*.t.lua}  \\
\ncangle{2,2}{3,3}
\ncangle{4,2}{5,3} \ncangle{4,2}{6,3} \ncangle{4,2}{7,3} \ncangle{4,2}{8,3} \ncangle{4,2}{9,3}
\end{psmatrix}
\caption{Схема рабочей копии} \label{fig:tests_at_working_copy}
\end{figure}

Причины подобной схемы расположения файлов можно узнать в главе <<Рабочее пространство>> документа <<Руководства программиста>>. К описанию из этой главы можно добавить некоторые подробности, касающиеся тестов:
\begin{itemize}
\item Файлы скриптов Lua (\path{*.lua}) и тестов к ним \path{*.t.lua} располагаются внутри пакетов\reason{Они являются файлами исходного кода, а не бинарниками, которым для запуска могут понадобиться внешние библиотеки и проще, если они будут лежать рядом}.
\item Пакет \path{testunit} обязателен для использования модульных тестов.
\item Иногда для тестов нужны вспомогательные файлы (БД, бинарные и текстовые файлы, образы виртуальных машин и пр.), они лежат в отдельной подпапке пакета с именем \path{_misc}. Их наличие или отсутствие -- лично дело разработчика пакета.
\item "<Плюсовый"> тестовый драйвер собирается в динамически загружаемую библиотеку \path{*.t.dll} или \path{*.t.so} в папку \path{_bin}.
\item Для сборки Test Container и запуска тестов используются библиотека и интерпретатор Lua, находящиеся в рабочей копии\reason{Это делает среду рабочей копии еще более независимой от среды операционной системы и установленных в ней компонентов}.
\end{itemize}

%-----------------------------------------------------
\subsection{Составные части}

Библиотека модульных тестов состоит из трех основных частей:
\begin{itemize}
\item <<плюсовый>> движок модульных тестов;
\item <<луновый>> движок модульных тестов;
\item <<запускалка>> тестов.
\end{itemize}

C++ Test Engine и Lua Test Engine аналогичны по архитектуре, но написаны на разных языках. Они содержат ту функциональность, которую не получиться вынести в Test Runner по причине языковых особенностей:
\begin{itemize}
\item механизм сбора тестов;
\item макросы проверки, обеспечивающие самопроверяемость тестов, они уникальны для каждого языка из-за типов данных переменных, проходящих проверку;
\item реализация синтаксиса написания тестов;
\item реализация защищенного вызова фукнции, что не позволяет одному заваленному тесту повалить весь процесс прогона тестов.
\end{itemize}

%-----------------------------------------------------
\subsection{Основные классы}

\begin{itemize}
\item Test -- абстрактный базовый класс тестов, содержит виртуальную фукнцию test()
\item TestFixture -- базовый класс, содержит виртуальные фукнции setUp() и tearDown()
\item TestCase -- базовый класс тестов, производный от Test и TestFixture содержит пустые setUp() и tearDown(). Чтобы в тесте иметь возможность использовать некоторые разделяемые ресурсы, то необходимо сначала создать "<живую"> TestFixture и унаследовать от нее конкретный класс TestCase-а.
\item TestSuite -- набор тестов, содержит список TestCase-ов
\item TestRegistry -- реестр тестов
\item TestObserver -- объект, получающий сообщения по ходу выполнения тестов и рассылающий их всем подписавшимся TestListener-ам
\item TestListener -- выводит сообщения о тестах туда, где их будет смотреть разработчик
\item TextTestProgressListener -- выводит сообщения о тестах в output в виде простого текста
\end{itemize}

%-----------------------------------------------------
\subsection{Механизм сбора тестов}

Этот механизм включает в себя создание объектов TestCase и их регистрация в реестре тестов.

В C++ Test Engine сбор TestCase-ов из всех файлов \path{*.t.cpp} производится за счет создания глобальных объектов классов-регистраторов, они создают в своем конструкторе статический объект конкретного класса, и регистрируют их в общем реестре "<плюсовых"> тестов (TestRegistry). Так регистрируются TestCase-ы. Получается что в момент загрузки тестового контейнера (файла \path{*.t.dll} или \path{*.t.so}) инициализируются все глобальные объекты и Test Registry оказывается заполнен списком всех тестов. При таком способе управлять составом тестов можно управлять только на этапе компиляции, включая/исключая файлы тестов (\path{*.t.cpp}) из компиляции. TestSuite-ы создаются автоматически при добавлении нового TestCase: если уже есть TestSuite с именем, равным пути к файлу, где определен TestCase, то тест добавляется в него, иначе сначала создается новый TestSuite.

В Lua Test Engine происходит следующий процесс: 
%%% \todo Завершить описание


%-----------------------------------------------------
\subsection{<<Запускалка>> тестов}

Одна из главных задач test\_runner-а -- это при помощи выставленных в Lua функций тестовых драйверов cpp\_unit и lua\_unit загрузить последние и получить от них "<луновые"> объекты с интерфейсом TestCase-а, т.е. имеющими фукнции setUp, test и tearDown и поле name\_. Ненужные тесты отфильтровываются (при этом из памяти объекты тестов не удаляются), а остальные проходят "<рамку теста">.

"<Рамка теста"> представляет из себя последовательный вызов фукнций \verb|setUp()|, \verb|test()| и \verb|tearDown()|, плюс в нужные моменты TestObserver-у посылаются сообщения о тестах (какой тест начал выполняться, как завершился, какой завершился и т.п.). Функция \verb|test()| не будет вызвана, если завершилась с ошибкой \verb|setUp()|. Если все-таки \verb|setUp()| выполнилась успешно, но будет вызвана \verb|test()| и обязательно -- \verb|tearDown()|. С помощью фукнций \verb|setUp()| и \verb|tearDown()| Вы можете инициализировать тестовую среду до выполнения теста и привести систему в исходное состояние после выполнения теста, чтобы не  мешать выполнению других тестов.

"<Плюсовые"> тестовые драйверы загружаются следующим образом. Во-первых, в память загружается динамическая библиотека самого cpp\_unit-а:\\ \verb|local getTestList = package.loadlib("../_bin/cppunit."..dllExt, "getTestList")|,\\ затем тестовые драйверы: \\ \verb|package.loadlib("../_bin/*.t."..dllExt, "")|.\\ Все тестовые драйверы используют объекты и фукнции, экспортируемые динамической библиотекой cpp\_unit-а, поэтому загруженные в текущий процесс динамические библиотеки тестовых драйверов имеют общие глобальные объекты, а следовательно пользуются одним реестром "<плюсовых"> тестов, в который вновь подгружаемый тестовый драйвер старательно складывает все свои тесты во время инициализации своих глобальных объектов.

"<Луновые"> тестовые драйверы грузятся банальнейшим образом -- при помощи фукнции dofile.

Т.к. подавляющий объем кода находится в test\_runner и он "<луновый">, то это упрощает процесс разработки и поддержки проекта за счет большей скорости разработки на скриптовом языке. Особенно это скажется при написании сложных TestListener-ов, коих нам понадобиться несколько типов, выдающих, например, полученные сообщения в определенном формате (txt, html, http-запрос) и на определенный приемник (консольный вывод, файл, syslogd, веб-сервер, Jabber Client). Для того, чтобы можно было на некотором количестве тестов запускать несколько наборов тестов без перезапуска, либо порождения отдльного процесса, нужно, чтобы при фильтрации списка запускаемых TestCase-ов сами объекты этих TestCase-ов не удалялись из памяти.

%-----------------------------------------------------
\subsection{Прогон тестов}

Для запуска тестов одного тестового контейнера можно использовать отдельный модуль \path{default_test_run.lua}. Командная строка запуска будет выглядеть примерно так:
\begin{verbatim}
lua5.1.exe -l testunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}
Вместо непосредственного указания пути к файлу контейнера (TEST~\_CONTAINER~\_PATH) можно указывать:
\begin{itemize}
\item SciTE: \verb`$(FileNameExt)`
\item Visual Studio 2010: \verb`$(TargetPath)`
\end{itemize}
Указывать \verb`TEST_CONTAINER_PATH` в двойный квадратных скобках необходимо, чтобы корректно обработать в пути обратные слэши (backslash).
Если testunit установлен в нестандартной папке и приложение-интерпретатор не может самостоятельно найти этот модуль, придется добавить в командную строку перед ключом \verb`-l` дополнительный код:
\begin{verbatim}
lua5.1.exe 
-e "package.path=[[PATH_TO_TESTUNIT/?.lua]]..package.path"
-l testunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

Запуск большого количества тестов (всего пакета, группы пакетов и т.д.) выполняется не разработчиком, а сервером непрерывной интеграции\footnote{Он пока не проработан}.

%-----------------------------------------------------
\subsection{Синтаксис модульных тестов}

Функции-assert и выражения для объявления тестов на C++ реализованы с использованием макросов только потому, что необходимо использовать макросы \verb`__FILE__` и \verb`__LINE__` для составления сообщения об ошибке в тесте, используя которое IDE сможет нас перенаправить на <<завалившийся>> assert. При использовании же функций, увидеть какой именно assert завалился можно только по CallStack-у, что противоречит принципу TDD о неиспользовании отладчика при разработке.

Синтаксис тесто на C++ получился таким потому, что:
\begin{itemize}
\item Макросы решили именовать также как переменные и функции для удобства ввода.
\item Пришлось переименовать функции класса TestCase: setUp, test и tearDown, - в innerSetUp, execute и innerTearDown соответственно потому, что они начали совпадать по именам с макросами и препроцессор пытался в коде вместо имени фукнции подставить содержимое макроса.
\item Возможность оставлять код ignore-тестов\footnote{невыполняемых} некомпилируемым удалось добиться за счет того, что этот код попадает в тело fake-овой шаблонной функции, которая не компилируется как неиспользуемая, реальная же функция execute определяется с пустым телом.
\item Теперь тело теста явно ограничено фигурными скобками, чтобы IDE правильно могло делать автоматический отступ от начала строки.
\item Макрос определения ignore-теста отличается от обычного только подчеркиванием в начале имени, т.к. это коротко, визуально различимо, можно использовать в заменах регулярными выражениями.
\item Макросы для задания тестов, использующих разное количество TestFixture, имеют разные имена, потому что в C++ нельзя перегружать макросы.
\end{itemize}

Синтаксис тестов на Lua опирается на следующие принципы:
\begin{itemize}
\item Не нужно писать require для модуля, реализующего синтаксис.
\item Не нужно объявлять контейнер с тестами отдельным модулем при помощи функции module.
\item Все функции, кроме объявленных как локальные\footnote{Например, \lua{local function someFunc() end}}, рассматриваются как тесты\reason{В этом случае отпадает необходимость следить за названиями функций, выделяя в них зарезервированные слова}.
\item Если имя теста начинается с символа подчеркивания (\_), то тест считается проигнорированным.
\item Фикстура объявляется как нелокальная таблица с двумя обязательными полями -- функциями setUp и tearDown.
\item Для того, чтобы тест использовал определенную фикстуру, нужно объявить его элементом данной фикстуры типа <<function>>, в примере тест addTest использует sampleFixture.
\item Все тесты тестового контейнера попадут в один TestSuite с именем, равным пути к файлу контейнера.
\end{itemize}

%-----------------------------------------------------
\subsection{Неразрешенные вопросы}

\FAQbegin


\fastQ Какие TestListener-ы нужны?

\fastA \ldots


\fastQ Схема фильтрации запускаемых тестов пока не продумана. 

\fastA Основная мысль в том, чтобы выставлять флаги разрешения выполнения в реестре тестов самого test\_runner-а. Однако, надо отметить, что поскольку тесты содержаться в файлах ("<луновые"> в \path{*.t.lua}, "<плюсовые"> в \path{*.t.dll}), то фильтрацией списка запускаемых тестов можно управлять на двух уровнях: физическом (файлами), логическом (списками уже загруженный тестов).


\fastQ Первоначально задумывалось оставить возможность запускать чисто "<плюсовые"> тесты, используя лишь "<плюсовый"> код, и аналогично для "<луновой"> части. Имеет ли смысл это реализовывать?

\fastA \ldots


\fastQ Сейчас класс TestCase реализован и на Lua и на C++, оправдано ли такое дублирование?

\fastA Если мы оставим только "<плюсовую"> реализацию, то не сможем тогда запускать "<луновые"> тесты без использования "<плюсового"> кода, теряется независимость частей движка.


\fastQ Необходимо ли сменить имя класса TestCase из-за измененной функциональности по сравнению с классической моделью модульных тестов xUnit-а?

\fastA Вероятнее всего. Название нужно придумать.


\fastQ Принадлежность TestCase-а к какому-либо TestSuite-у отражать только в названии?

\fastA Это самый простой способ. Если в общем реестре тестов начать делать иерархии, то это должно быть оправдано, можно опять к этому вернуться, когда более подробно будут проработаны требуемые критерии фильтрации списка выполняемые тестов.


\fastQ А если мы загружаем тестовые модули, собранные для разных версий cppunit, у к-ых одинаковые интерфейсные функции?

\fastA Главное - это чтобы не менялся интерфейс и поведение класса TestCase, а остальное не важно. А если будут отличаться, то мы упадем и все ("<мертвые программы не лгут">). Хотя могут быть сложности с выявлением ошибки подобного типа.


\fastQ В итоге получилось, что в Lua из C++ выставлено только TestCase и фукнция по предоставлению их списка?

\fastA Больше пока ничего выставлять не надо, получается обходиться этим. 


\fastQ Если рассмотреть гипотетическую ситуацию, что у нас не два, три и более языков с модульными тестами, которые необходимо запускать однотипным образом, применяя принцип полиморфизма?

\fastA Ну ситуация-то не такая уж и гипотетическая, ведь можно считать другим языком и язык скриптов, SQL, которыми мы также пользуемся, и еще самые низкоуровневые библиотеки можно писать в рамках ANSI C, что добавляет еще один язык. А что касается о стратегии "<прикинуться как другие">, то можно действовать так: сами языки наверняка имеют C API, нужно просто используя его написать и выставить в Lua тот же набор объектов и фукнций, что и для C++. Хотя такого рода "<заворачивание"> используя и Lua. Главное при этом помнить, что модульные тесты обычно пишутся на том же языке, что и основной код. Если от этого приходиться отказываться, то реализация пошла не тем путем.


\fastQ Это все конечно неплохо выглядит, но при этом собственно файлы с тестами получаются пассивными, их не получится использовать независимо, не прибегая к "<запускалке">

\fastA Ну вариант stanalone теста хорош, когда ковыряешься конкретно в нем и запускаешь его в гордом одиночестве. Но когда необходимо запустить десятки и более тестов и получить по ним СУММАРНУЮ статистику, то ничего не выйдет хорошего. Можно и с придуманной схемой эмулировать такое поведение используя фильтрацию списка запускаемых тестов, ну и еще обвешать в достаточной мере скриптами IDE. Главное ведь не в том, насколько сложна система, а насколько ей удобно пользоваться. При правильном подходе пользователи и разницы-то не почувствуют. Лично у меня для файлов \path{*.t.lua}, к-ые, я считаю по-умолчанию, написаны под lunit, запускаются более заковыристой командой с выполнением предварительного кода, передаваемого Луне в параметре --e. Это самый простой пример.


\fastQ Ну допустим, сделали мы пакет полезного кода, пару модулей на Lua, несколько на C++, и естественно тесты к ним. Что еще должно находиться в составе пакета (а может быть и нет), чтобы эти тесты можно было прогонять?

\fastA Было бы заманчиво сделать пакет независимым в плане: "<загрузил и все есть">, но это как с компилятором, штука отдельная от собственно кода. Так и запускалка, она ведь может, по-идее использовать кучу сторонних модулей и таскать их с каждым пакетом неразумно. Надо просто принять, что пакет можно "<откомпилировать">, а можно "<протестировать">.


\fastQ Подойдет ли данная модель в случае, когда у нас хостовым приложением является не сам Lua интерпретатор, а какое-нибудь из разрабатываемых нами приложений?

\fastA Т.е. нужно предусмотреть возможность подмены дефолтового интерпретатора другим. Проблема может быть в том, что у нас, скорее всего, в нашем хостовом приложении будет жестко ограничен набор используемых модулей, урезаны даже стандартные библиотеки и т.п., и оставшегося может просто не хватить для работы движка "<запускалки тестов">. Т.к. еще неизвестно как это будет выглядеть в действительности, то сейчас и рассуждать особо не стоит, как и совсем забывать об этом.
\FAQend

%-------------------------------------------------------------------------
\subsection{w01481. Подобрать схему запуска тестов при работе с MSVC и SciTE}

\FAQbegin
\fastQ Процесс сборки "<плюсовой"> части движка (Cppunit ??)

\fastA Сам CppUnit, входит в состав afl, будет представлять из себя один модуль (см. пост выше), зависит от модулей, где реализованы Thunk и типы данных. Но собирать-то его необходимо в DLL-ку (см. пост выше, чтобы узнать причину), вряд ли весь afl будет использоваться тем же способом, следовательно под его сборку нужно завести отдельный проектник. Библиотеку импорта нужно складывать в \path{_lib}, саму DLL-ку -- в \path{_bin}, т.к. она нужна для тестов различных пакетов, и ее незачем дублировать для каждого. 


\fastQ Сколько "<плюсовых"> тестовых драйверов может быть сделано от одного пакета?

\fastA Наверное, столько же сколько есть проектников в этом пакете. Вопрос только в том, могут ли при этом одни и те же тесты войти в разные тестовые драйверы? По идее каждый из тестов полностью независим и не влияет на запуск других тестов, единственный минус от множественного запуска одного и того же теста -- потеря времени. 

\fastA Не совсем верно, т.к. в одном проектнике могут быть несколько конфигураций (допустим, они отличаются наличием или отсутствием некоторых макросов), считай, каждай имеет свой вариант кода, соответственно и свой набор тестов.


\fastQ Получается, что все тестовые драйверы лежат одной большой кучей, а нам каким-то образом нужно выцепить и запустить лишь несколько из них при разработке одного пакета?

\fastA Получается так. Причем, учитывая, что имя проектника может не совпадать с именем собираемой библиотеки, то их не получится брать в качестве опорной точки в поисках. Проще и надежнее будет в начале имени тестового драйвера указывать имя пакета. 


\fastQ Сейчас за счет использования заголовочных файлов "<плюсовые"> пакеты могут находить друг друга в пределах одной рабочей копии, можно создавать локальные тестовые среды. По идее той же схемы хотелось бы придерживаться и для "<луновых"> модулей, чем они собственно хуже?

\fastA Если действовать по аналогии с "<плюсовыми"> пакетами, то придется в require указывать и имя пакета, к которому относится нужный модуль. Это дает возможность сделать нормальную песочницу для разработки, к-ой безразлично, что установлено в системе. Кстати можно довести эту схему до абсолюта и интерпретатор Lua тоже собирать и использовать тот, что в песочнице, а не в системе.
Например, так работает (из-за особенностей паттерна пути в require не получится указать директорию "<..">):
\begin{lstlisting}[language=lua]
package.path="../?.lua;"..package.path
local fs = require("svn_wv_lua_scripts/filesystem");
print(fs.whatOs());
\end{lstlisting}

\fastQ Не приводит ли это нас к выводу, что нужно файлы тестов выкладывать в папку \path{_bin}?

\fastA Неа. Это ведь по сути исходники. Будем считать это за особенность разработки на скриптовых языках.


\fastQ Отставим пока в сторону вопрос о месторасположении. Как мне при разработке в MSVC или SciTE запустить один тестовый драйвер на выполнение?

\fastA Ну поскольку для студии можно установить лексер Lua, то можно предположить, что "<луновые"> скрипты включены прямо в проектник и правятся из студии. SciTE поддерживает Lua по-умолчанию. Следовательно запустить хочется тот тестовый драйвер, что сейчас открыт на редактирование, осталось только "<волшебную кнопку"> надавить. А перед сдачей проекта необходимо прогнать все его тесты, делаем активным проектник в дереве и жмем "<волшебную кнопку">. Ну это касалось чисто "<луновых"> пакетов, с ними по идее можно однообразно работать и в MSVC и в SciTE. А вот с "<плюсовыми"> так не получится, т.к. чтобы исключить какой-то TestSuite из компиляции, для студии подобные тесты написаны, их можно использовать. А при использовании чисто SciTe либо придется самостоятельно ковырять лежащий в папке пакета проектник, что ни есть хорошо, либо генерить Makefile, т.е. испоьзовать систему сборки, альтернативную той, что юзает MSVC. Смена системы сборки нам в ближайшем будущем не светит, поэтому нужно искать схему, которая подойдет в обоих случаях. Вспоминаем, что мы все-таки планировали фильтровать список тестов перед запуском, остается лишь определиться как мы определяем, что именно оставлять. Вариант с определением имен тестов путем парсинга исходников не кажется радужным, а вот получить информацию о файлах, будь то исходник, который мы сейчас ковыряем, или даже бинарник "<плюсового"> теста, путь к которому хранят недра проектного файла, то это более понятный и близкий вариант реализации. Отсюда делаем вывод, что скрипту, запускающему некий нужный нам набор тестов должен получить на вход список файлов (\path{*.t.lua}, \path{*.t.dll}) либо папок, в которых нужно поискать файлы с вышеуказанным расширением.


\fastQ В каких случаях тогда нужна фильтрация с использованием имени теста?

\fastA Похоже предложении предыдущего ответа не был учтен вариант запуска одного TestSuite-а, написанного на C++, при условии, что в тестовый драйвер пакета компилируются все имеющиеся в нем тесты. Было уже показано, как скриптами MSVC поправить это положение, но в ситуации испоьзования SciTE вопрос остается открытым. Как поступить? Ну как вариант можно установить курсор на имя нужного TestSuite-а, и вызвать сначала функцию, которая может определить слово под курсором (либо можно пользователю самому выделить имя, будет еще проще, правда скрипту, а не пользователю :-) ), и передать эту инфу скрипту. Делаем вывод, что скрипт может получать пути к файлам, к папкам и имена тестов, которые нужно запустить, выделив из общего списка. Имннт смысл распространить этот usecase (образец использования) и на MSVC, чтобы не путаться.


\fastQ Кстати как он их получит из той же SciTE? Точнее такой вопрос: как получить полный список файлов \path{*.t.lua} и \path{*.t.dll}, относящихся к определенному пакету?

\fastA Все-таки тут без парсинга \path{*.vcproj}-файлов не обойтись, без этого не определить ни какие из \path{*.t.lua}-файлов относятся к данному проекту, ни определить под каким именем собираются бинарники тестовых драйверов. Значит располагать последние в пределах папки пакета не имеет смылса, при отсутствии плюсов, мы получаем больше мороки. Теперь насчет бинарников, достаточно уникальным будет имя DLL, состоящее из имени пакета, имени проектника пакета и названия конфигурации данного проектника, завершает все это расширение \path{*.t.dll}.

\fastA Стоит добавить, что это не относится к таким конфигурация проектного файла, как release, debug, test, а только к тем, в которых каким-то образом изменена функциональность прикладного кода. Тогда учитывая это придется, оставлять на изучение только те конфигурации, что содержат в развании слово test, в начале либо в конце, а узнавать, с каким именно имененм собирается тестовый драйвер -- из опции OutputFile.


\fastQ Получается, что вся информация, необходимая для запуска набора тестов получается из текущего редактора, либо из \path{*.vcproj}-файлов, т.е. никакого дополнительного файла настроек в пакете не нужно ?

\fastA Пока в это действительно нет необходимости. 


\fastQ Вроде бы не был прояснен вопрос с "<луновыми"> тестами к "<плюсовому"> коду, выставленному в Lua, он вроде не сильно вписывается в эту схему?

\fastA 

\FAQend

%-----------------------------------------------------------------------------------------
\subsection{w05147 Сделать apollo unit}
% \todo Переделать на пакете MetaUML
\begin{enumerate}[]
\item Факт: OLEDB выставлено в Apollo, а не в Lua
\item $\to$ Факт: скрипты в chimera должны выполняться в заданном нами окружении (a'la sandbox)
\item $\to$ $\to$ В скриптах chimera нельзя использовать require
\item $\to$ $\to$ $\to$ =: apollounit сам будет загружать модули chimera, например, oledb.
\item $\to$ $\to$ $\to$ =: apollounit будет находиться в репозитории chimera из-за своей специализации
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: для загрузки тестовых контейнеров cppunit-а используется платформозависимая функция package.loadlib
\item Факт: для загрузки тестовых контейнеров luaunit-а специально подготавливается область видимости
\item $\to$ Предположение: процедура загрузки тестовых контейнеров может быть нетривиальной
\item \ldots
\item $\to$ тестовые контейнеры не являются полноценными модулями Lua и не должны грузиться функцией require
\item $\to$ $\to$ =: LTUE сами производят загрузку своих тестовых контейнеров
\item $\to$ $\to$ =: тестовые контейнеры не являются полноценными скриптами/модулями/библиотеками
\item $\to$ $\to$ $\to$ =: Test Runner не знает сколько и какие тесты содержатся в тестовых контейнерах

% \item Факт: LTUE часть структуры \testunit
% \item Факт: тестовых контейнеров много больше, чем LTUE 
% \item =: тестовые контейнеры не несут функциональности, расширяющие \testunit
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: модули Lua могут быть как бинарными, так и текстовыми
\item Факт: Lua грузит модули однотипно командой require
\item LTUE представляют из себя модули Lua
\item $\to$ =: LTUE должны нормально грузиться командой require
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: модульные тесты пишутся на том же языке, что и прикладной код
\item Предположение: в рамках этого языка создаются классы (если класс поддерживает ООП) и объекты, олицетворяющие тесты
\item $\to$ =: каждый LTUE при загрузке тестов из тестового контейнера формирует локальный реестр тестов в рамках своего языка
\item \quad Факт: Test Runner-у нужны объекты в его Lua VM, чтобы запускать тесты
\item $\to$ $\to$ =: LTUE должны дать Test Runner-у <<ниточки>> управления тестами (binding), которые они собрали из тестовых контейнеров
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Предположение: возможно нужно будет написать Test Runner на другом языке (м.б. и скриптовом, м.б. и нет)
\item Предположение: каждый LTUE должен иметь реализацию на своем языке и binding-и в языки, использованные при написании Test Runner-а(ов)
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: при разработке во время сборки проекта с тестами для их прогона Test Runner вызывается через командную строку 
\item Факт: при выполнении автоматических сборок проекта тесты будет выполнять Continuous Integration Server
\item Факт: для Hudson/Jenkins CI Server может быть написан plugin на Java для прогона тестов
\item Предположение: одновременно может использоваться несколько Test Runner-ов, написанных на разных языках программирования
\item Предположение: LTUE придется выставляться во все языки, использованные при создании Test Runner-ов
\item Предположение: Test Listener придется переписать на языке, использованном при создании Test Runner
\item \end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт$\ominus$: сейчас Test Runner сам знает о имеющихся LTUE, чтобы добавить/удалить хоть один необходимо изменить исходный код Test Runner-а
\item Предположение: нужно, чтобы этот список формировался динамически
\item =: Test Runner-у на вход отдается полный список путей к файлам тестовых контейнеров
\item =: LTUE сами производят загрузку своих тестовых контейнеров
\item Факт: прежде чем загрузить тестовый контейнер нужно подгрузить все LTUE
\item =: список LTUE отдается Test Runner-у вместе со списком файлов
\end{enumerate}
\divblock{==============================}
% тесты распознаются по расширению
\begin{enumerate}[]
\item Факт: тестовые контейнеры могут быть как текстовыми файлами, так и бинарными
\item =: LTUE сами производят загрузку своих тестовых контейнеров
\item Факт: файлы отличаются именем и расширением
\item Факт: текстовые файлы могут иметь разные кодировки
\item Факт: в начале тела текстовых файлов могут находиться служебные метки, например, BOM
\item Факт: содержимое текстовых файлов может быть записано с использование широких и узких символов
\item Факт: формат бинарных файлов DLL, генерируемых VS сложен
\item $\to$ Предположение: заглянуть в файл тестового контейнера даже одним глазком будет непросто
\item $\to$ $\to$ Предположение: не получиться решить проблему меткой внутри тестового контейнера
\item \quad Факт: ОС обычно понимает какая программа может открыть тот или иной файл по его расширению
\item $\to$ $\to$ =: Различать тестовые контейнеры нужно по имени и расширению 
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item =: Различать тестовые контейнеры нужно по имени и расширению 
\item Факт: имя от расширения отделяется точкой
\item Факт: подчеркивание -- допустимый символ в имени файла и он часто используется для разделения слов друг от друга
\item Факт: определить текстовый файл или бинарный можно по расширению
\item Факт: файлы одного компонента связаны общим префиксом имени (от начала до первой точки)
\item $\to$ Предположения: нужно дополнительное расширение в имени файла обозначающее, что это файл не с прикладным, а с тестовым кодом, например, t
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Предположения: нужно дополнительное расширение в имени файла обозначающее файл с тестовым кодом, например, t
\item Предположение: скрипт-main может не знать все LTUE, необходимые для загрузки тестовых контейнеров
\item $\to$ Предположение: смогут загрузиться не все указанные Test Runner-у файлы тестовых контейнеров
\item Предположение: будет проще, если скрипт-main будет общим для загрузки тестовых контейнеров любого из LTUE
\item Предположение: Test Runner заранее не знает как определить какие тестовые контейнеры какими LTUE могут быть загружены
\item $\to$ =: Test Runner должен спрашивать у LTUE может ли он загрузить тот или иной тестовый контейнер
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: есть apollo -- библиотека Lua на wchar\_t. 
\item Факт: скриптам, написанным под apollo необходимо выполняться в рамках VM Apollo
\item Факт $\ominus$: luaunit (Lua Test Unit Engine), использующий стандартную Lua не в состоянии корректно выполнять тесты для Apollo
\item Факт $\oplus$: архитектура testunit предполагает расширение набора Language Test Unit Engine-ов
\item =: Необходимо сделать отдельный LTUE -- apollounit, который:
    \begin{itemize}
    \item может загрузить и выполнить скрипт под Apollo
    \item выставляет тот же интерфейс (в стандартную Lua), что и luaunit, cppunit, чтобы Test Runner мог с ним общаться
    \end{itemize}
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: apollounit-у необходимо выставиться в стандартную Lua на узких символах (т.е. использовать \path{lua/lua.h} и линковать lua5.1.lib)
\item Факт: apollounit-у необходимо использовать C API Apollo, чтобы выполнять свои тесты (т.е. использовать \path{apollo/lua.h} и линковать apollo.lib)
\item Предположение: тесты к apollounit-у -- это отдельные текстовые файлы
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: для написания модульных тестов нужно использовать LDE, установленную в системе
\item $\to$ Предположение: apollounit должен линковать Lua из LDE, т.е. динамически
\item Факт: функции из C API Lua и Apollo имеют одинаковые имена
\item $\to$ чтобы использовать их одновременно нужно линковать один статически, другой -- динамически
\item $\to$ $\to$ Предположение: apollounit-у придется линковать apollo статически
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Факт: расширением пользуется ОС
\item Факт: есть язык APL, т.е. нельзя использовать расширение \path{apl}
\item Факт: расширение \path{a} используется для обозначения файлов статических библиотек, генерируемых GCC и MinGW
\item Предположение: расширение не должно быть длинным
\item Apollo -- это Lua на широких символах wchar\_t, но по идее, это другой диалект языка
\item $\to$ Предположение: выбрать для apollo-скриптов расширение \path{alua}
\item $\to$ Предположение: для разных диалектов одного языка использовать разные расширения
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item Противоречие: 
\item Факт: что можно сделать на Lua, то можно сделать и с использованием C API Lua
\item Факт: трудоемкость реализации на C API Lua выше, чем на Lua
\item Факт: apollounit придется содержать ту же функциональность, что любой другой LTUE
\item $\oplus$ apollounit может полностью использовать код luaunit
\item $\ominus$ код luaunit в этом случае должен выполниться в рамках VM Apollo
\item Факт: нет интерпретатора Apollo, есть только библиотека
\item =: Код luaunit нужно будет сконвертировать в UCS2 и переименовать в \path{apollounit.alua}. apollounit будет выступать за интерпретатор Apollo и загрузит его внутри себя 
    \begin{itemize}
    \item $\ominus$ будет дублирование кода luaunit, но только в другой кодировке
    \item $\oplus$ трудоемкость реализации ниже
    \end{itemize}
\end{enumerate}
\divblock{==============================}
\begin{enumerate}[]
\item =: Apollounit, как LTUE, реализован в виде \path{apollounit.dll}
\item =: основная функциональность содержится в \path{apollounit.alua}
\item $\to$ Предположение: задачей \path{apollounit.dll} будет только загрузить \path{apollounit.alua} и перебрасывать вызовы из VM Lua в VM Apollo и ответы в др. сторону. Т.е. основное назначение -- выставиться в Lua.
\end{enumerate}

%-----------------------------------------------------------------------------------------
\subsection{Требования с совещания 11 декабря 2010 г.}

\begin{itemize}
\item Закрыв каждый тест своим namespace-ом можно защитить их от <<глобальных>> переменных друг друга\footnote{Это наверное относиться не к C++, а к Lua. Сами тесты не смогут объявить объект в области вне своей функции}.
\item После завала одного из assert-ов теста, следующие за ним не выполняются.
\item <<Вырезание>> кода теста путем установки <<флага>> о том, что он проигнорирован. Данный код не должен компилироваться\footnote{Реализовано}.
\item В коде теста могут вызываться как C++, так и SEH исключения. Они не должны <<валить>> прогон тестов, но после SEH его нужно корректно остановить, т.к. состояние процесса уже может быть катастрофическим.
\item Нужно уметь сообщать, что тест завалился именно в setUp, test или tearDown для упрощения процесса локализации ошибки
\item Использовать лямбда функции (и std::function) из стандарта 0xC++ вместо Thunk.
\item Защита от бесконечных циклов внутри тестов.
\item Защита от неожиданного SEH исключения в тесте конкретного тестового контейнера. Т.е. чтобы можно было бы не останавливать полностью прогон тестов, а пропустить только тесты одного тестового контейнера.
\end{itemize}

%-------------------------------------------------------------------------------------------------------------
\section{Issures}
\begin{itemize}
\item TestRunner не должен знать о конкретных Language Unit Engine. Их нужно уметь грузить динамически при запуске.
\item Загруженные Language Unit Engine-ы должны сообщить TestRunner о том, какие расширения файлов идентифицируют тестовые контейнеры, с которыми они могут работать.
\item Language Unit Engine, а не TestRunner, должен сам уметь загрузить тестовый контейнер.
\item Переименовать TestObserver и его фукнции так, чтобы не казалось, что именно он запускает тесты.
\item Настроить в VS2010 запуск отладки тестового контейнера так, чтобы output процесса выводился бы в OutputWindow, а не в свое консольное окно. Тогда можно будет двойным кликом на строке с ошибкой прыгнуть на проблемное место, в противном случае вся информация так и останется в отдельном консольном окне.
\item Каждому загружаемому тестовому контейнеру нужны свои значения для переменных среды и определенная рабочая папка при выполнении.
\item Зачем использованы Thunk-и, можно ли обойтись без них?
\item Фукнции TestRegistry::reinitialize(TestRegistry* newValue) нужно реализовать по-умному, открыв только тестам самого cppunit-а, а не всем остальным.
\end{itemize}



