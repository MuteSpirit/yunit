%--template 'shared_template.tex' --def title='Модульное тестирование'

\newcommand{\testunit}{testunit} % unit test library draft title

%-------------------------------------------------------------------------------------------------------------
\section{Использование экстремального тестирования}

%-----------------------------------------------------------------------------------------
\subsection{Зачем проводить тесты}

\begin{itemize}
\item Вы знаете, что система работает
\item Вы знаете, что работаете на стабильной программной платформе\footnote{Т.е. все компоненты, от которых зависит разрабатываемый вами код протестирован и соответствует своей спецификации}.
\item Вы знаете, что последние изменения (сделанные после последнего пройденного теста) не добавили в программу ошибок.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Результаты обратной связи от модульных тестов}

\begin{itemize}
\item У вас есть уверенность в том, что созданный фрагмент действительно работает.
\item Тесты дают разработчику <<страховочную сеть>>. Вы можете смело вносить изменения, в том числе большие по объему и достаточно рискованные. Если вы сделали ошибку, то узнаете об этом очень быстро.
\item Вы почти не используете программы отладки. Вы сразу же узнаете о том, что какая-то часть системы дает сбой, т.к. не сделали ничего после последнего удачного теста и точно знаете, какой именно тест не был пройден. Поэтому проблему можно обнаружить достаточно быстро.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Бонусы от использования модульных тестов}

\begin{itemize}
\item Ускорение разработки и повышение качества выпускаемого кода. За счет раннего тестирования исходного кода на уровне модулей уменьшается количество ошибок, проникающих на уровень приложения, т.е. снижается время на их выявление и отладку, что покрывает все расходы на написание модульных тестов.
\item Можно воспроизводить в тестах такие условия (контекст) вызова кода, который получить в реальных и тестовых условиях использования продукта очень трудно. Тем самым снижается число трудноуловимых ошибок.
\item Тесты являются документацией к коду, по ним видно как именно его нужно использовать. Такая документация не потеряет актуальности пока эти тесты выполняются успешно.
\item Тесты дают возможность комфортно проводить рефакторинг кода. Тесты проследят за тем, чтобы поведение улучшаемого кода осталось прежним.
\item stub- и mock-объекты позволяют производить независимую разработку зависимого и влияющего кода.
\item Тесты можно использовать при рецензировании кода, например, рецензент может добавлять полезные, на его взгляд, тесты, выявляющие проблемы в рецензируемом коде.
\item Тесты снижают цену ошибки. Если код тестируется на уровне модуля, особенно низкоуровневого, то объем кода тестов достаточно мал. Но если для того, чтобы протестировать код, вам приходится писать более высокоуровневый код, например, делающий доступ  к новой функциональности из графического интерфейса, то в случае возможной ошибки вам придется исправлять намного больший объем кода: и свой, и весь вспомогательный.
\item Поскольку тесты заставляют писать классы, которые можно протестировать отдельно, без привлечения стороннего кода (заменяя, например, его mock объектами), то код получается более структурированный и лучше спроектированный.
\item По поведению тестов можно отслеживать огрехи в архитектуре, например:
    \begin{itemize}
    \item если ваши тесты начинают ломаться в самых непредсказуемых местах, это означает, что одна часть разрабатываемого приложения непредсказуемым образом влияет на другую его часть;
    \item если ваш код начальной инициализации теста вгоняет в тоску своим объемом, это значит что ваши объекты слишком большие и их требуется разделить;
    \item если вы не можете быстро найти общее место для общего кода инициализации и у вас остается в нем дублирование, это означает что у вас слишком много объектов, которые слишком тесно взаимодействуют друг с другом.
    \end{itemize}
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Где модульные тесты <<не работают>>}

\begin{itemize}
\item Многопоточное и многопроцессное программирование;
\item Тестирование графического интерфейса \footnote{Поэтому приходится отделять бизнес-логику от интерфейса, чтобы ее протестировать};
\end{itemize}

Если прогон модульных тестов во время процесса разработки требует значительного времени (порог -- 10 сек), то программист будет запускать их недостаточно часто и практическая польза от тестов снизиться (возможно до нуля).

Если прогон регрессионные тестов будет выполняться дольше 10 мин, то ситуация будет аналогично предыдущей.

%-----------------------------------------------------------------------------------------
\subsection{Отрицательная сторона модульного тестирования}

\begin{itemize}
\item На написание тестов тратиться время.
\item Тесты -- это дополнительный код, который нужно сопровождать.
\item При изменении требований придется переделать не только прикладной код, но и тесты к нему.
\end{itemize}


%-----------------------------------------------------------------------------------------
\subsection{Полезные советы}

\begin{itemize}
\item Пишите тесты с максимально просто, чтобы отсутствие ошибки можно было проверить визуально. В противном случае нужно будет писать тесты для самих тестов, что порождает излишне сложную и непрактичную схему. Т.е. избегайте использования в тестах ветвлений кода, циклов и др. сложных конструкций, старайтесь, чтобы код теста был линейным.
\item Если вы обнаружили в коде ошибку, которая проявлялась при выполнении тестов, то перед тем как ее править, напишите тест, выявляющий эту ошибку. Теперь вы будете уверены, что в будущем она не всплывет вновь.
\item Старайтесь писать хорошие тесты. В противном случае вы получите чувство ложной уверенности в работоспособности вашего кода.
\item Применяя TDD вы <<впишете>> тесты в сам процесс разработки, вам не нужно будет насильно заставлять себя разрабатывать тесты, вы перестанете считать их бесполезным кодом, на который к тому же тратиться драгоценное время, отведенное на реализацию полезной функциональности.
\end{itemize}

%-----------------------------------------------------------------------------------------
\subsection{Что за такое TDD}

TDD (Test Driven Development) переводиться как <<разработка через тестирование>>. А именно, сначала пишутся тесты, и только потом сам код, который они тестируют.

Вот так примерно выглядит процесс разработки по данной методике:
\begin{itemize}
\item Создаем новый тест. При его написании мы определяемся с тем, что именно хотим получить и как использовать. Можно назвать это этапом постановки требований к своему коду.
\item Убеждаемся, что он не компилируется.
\item Создаем код, реализующий вызываемые в тесте интерфейсы.
\item Убеждаемся, что тест компилируется, но тестовый драйвер не линкуется.
\item Создаем пустую (fake) реализацию.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется, но валиться при выполнении.
\item Создаем нормальную реализацию кода.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется и успешно выполняется.
\item Проводит рефакторинг прикладного кода.
\item Убеждаемся, что тест компилируется, тестовый драйвер линкуется и успешно выполняется.
\item Запускаем регрессионные тесты, убеждаемся, что они все проходят.
\item Сдаем код в репозиторий.
\end{itemize}

Если вы имеете достаточно опыта в TDD, то вы можете решить для себя, что приемлемо пропускать некоторые промежуточные шаги, можете работать сразу над несколькими тестами и т.д.

Что хорошего в TDD, так это то, что решение большой задачи разбивается на последовательность мелких обозримых шажков, позволяющих думать в один момент времени только над одной частью общей задачи и не держать в голове несколько аспектов сразу.

%-------------------------------------------------------------------------------------------------------------
\section{Библиотека модульных тестов \testunit}

Рабочее название -- \testunit. Предлагаемое: YUnit.

%-----------------------------------------------------------------------------------------
\subsection{Список терминов и сокращений}

\begin{tabulary}{\textwidth}{p{\textwidth}}
{\bfseries <<Движок>>/библиотека модульных тестов (Test Unit Engine)} -- вся библиотека \testunit\ как отдельный пакет \\
{\bfseries Контейнер тестов (Test Container)} -- файлы, содержащие набор тестов в некотором формате (\path{*.t.dll}, бинарный формат в случае тестов на C++ (C++ Test Container) и \path{*.t.lua}, текстовый формат в случае тестов на Lua (Lua Test Container)\\
{\bfseries Тестовый драйвер (Test Driver)} -- это набор тестов и сценарий запуска для содержащихся в них тестов \\
{\bfseries <<Запускалка>> тестов (Test Runner)} --  та часть функциональности библиотеки \testunit, которая отвечает за поиск, загрузку тестовых контейнеров, получение из них списков тестов, их запуск и публикация результатов прогона тестов \\
{\bfseries <<Движок>> тестов для определенного языка программирования (Programming Language Test Engine)} -- та часть функциональности библиотеки \testunit, которая отвечает за синтаксис тестов, набор тестовых проверок, составление коллекции тестов в Test Container-е и защищенный вызов тестовых функций для тестов, написанных на определенном языке программирования. На данный момент реализованы два таких <<движка>>: C++ Test Engine и Lua Test Engine \\
{\bfseries } Тест кейс (контрольный пример) (Test Case) -- один отдельный тест \\
{\bfseries } Набор тестов (Test Suite) -- набор тест кейсов \\
\end{tabulary}

%-----------------------------------------------------------------------------------------
\subsection{Quick Start}

%---------------------------------------------------------------------
\subsubsection{Установка}

Инсталлятор\footnote{Исходники можно получить, сделав клон репозитория Mercurial: \path{hg clone http://scm.til.int:8080/lde lde}} находится здесь:\\
\path{\\file\repo\lde\distributives\x.x.x.x\setup_lde.msi}

\begin{itemize}
\item Для установки требуются права администратора
\item Устанавливаются:
    \begin{itemize}
    \item Lua 5.1 (включающую все официальные патчи) (интерпретатор, библиотеки).
    \item Библиотека \testunit\ (бинарные модули, h-файлы, lib-файлы).
    \item Прикладные вспомогательные модули (atd, lopt, clear и т.д.).
    \end{itemize}
\item Для файлов с расширением \path{*.lua} регистрируется иконка с логотипом Lua.
\end{itemize}

Если какая-то версия Lua уже установлена, то необходимо деинсталлировать ее:
\begin{itemize}
\item удалить путь к папке с lua5.1.exe из переменной окружения PATH (и системной, и пользовательской) (обязательно);
\item удалить переменные среды LUA\_PATH и LUA\_CPATH (системные и пользовательские) (обязательно);
\item удалить файлы установленных интерпретатора, библиотек и модулей, если Вы знаете, что делаете (опционально).
\end{itemize}

Для начала установки просто дважды кликните на файл и следуйте указаниям мастера установки.

%---------------------------------------------------------------------
\subsubsection{Первый тест на Lua}

\begin{enumerate}
\item Создайте файл с расширением \path{*.t.lua}.
%
\item Добавьте в него следующий текст при помощи SciTE:
\begin{lstlisting}[language=lua]
function test()
    isTrue(false ~= true);
end
\end{lstlisting}
%
\item Сохраните.
%
\item Откройте файл локальных настроек SciTE (меню <<Options>> $to$ <<Open Local Options File>>)
%
\item Вставьте в него строку:
\begin{verbatim}
command.go.*.t.lua=lua5.1.exe  -l load_scite_listener
-l testunit.default_test_run -e "run('$(FileNameExt)')"
\end{verbatim}
%
\item Сохраните.
%
\item Перейдите на вкладку с открытым файлом теста
%
\item Нажмите F5
%
\item В Output Window Вы увидите результат выполнения теста:
\begin{verbatim}
[.]
Execution of tests has been completed:
			Failed:      0
			Errors:       0
			Ignored:     0
			Successful:  1
			Total:       1
\end{verbatim}
Тест был успешно пройден.
%
\item Добавим в файл еще несколько тестов:
\begin{lstlisting}[language=lua]
function failedTest()
    isTrue(false)
end

function _ignoredTest()
    isTrue(false)
end
\end{lstlisting}
%
\item Нажмите F5
%
\item В Output Window Вы увидите результат выполнения теста (только имя файла будет то, что задали Вы):
\begin{verbatim}
[I.F]
Execution of tests has been completed:
			Failed:      1	(0_-) BUGS !!!
			Errors:       0
			Ignored:     1	o(^_^)o ?
			Successful:  1
			Total:       3

lua_sample.t.lua::failedTest
	lua_sample.t.lua(6) : true expected but was nil or false
lua_sample.t.lua::_ignoredTest
\end{verbatim}
По сообщениям видно, что тест \verb`lua_sample.t.lua::failedTest` завалился, а тест \verb`lua_sample.t.lua::_ignoredTest` не был проигнорирован и не выполнялся.
Сделав двойной клик мышью на строке, либо нажав F4:
\begin{verbatim}
lua_sample.t.lua(6) : true expected but was nil or false
\end{verbatim}
Вы переместитесь на строку со сработавшим assert-ом
\end{enumerate}

%-----------------------------------------------------------------------------------------
\subsection{Синтаксис}

%-----------------------------------------------------------------------------------------
\subsection{C++ Test Engine}

%---------------------------------------------------------------------
\subsubsection{Тесты}
\label{sec:cpp_test_syntax}

\begin{lstlisting}[language=c++]
////////////////////////////////////////////////////////////
// component.t.cpp
//
////////////////////////////////////////////////////////////
#include <tesunit/test.h>

test(testA)
{
    isTrue(true);
    isFalse(false);
}

fixture(fixtureA)
{
    // will be executed BEFORE every test, used this fixture
    setUp()         
    {
        a_ = 10;
    }
    // will be executed AFTER every test, used this fixture
    tearDown()
    {
        a_ = 0;
    }
    
    // fixture members:
    // they are used by tests. Every test use it's own copy of them
    int a_;         
};

// fixtureA::setUp() will be called before testB and fixtureA::tearDown() - after.
test1(testB, fixtureA)
{
    areEq(10, a_); 
}

fixture(fixtureB)
{
    setUp()
    {
        b_ = 11;
    }
    tearDown()
    {
        b_ = 0;
    }
    int b_;
};

// fixtureA::setUp() and fixtureB::setUp() will be executed before testC
// fixtureB::tearDown() and fixtureA::tearDown() will be executed after testC
test2(testC, fixtureA, fixtureB)
{
    areEq(10, a_); 
    areEq(11, b_); 
}

// ignored test case (may have uncompiled code in body)
_test(testD)
{
    int uncompiledCode[0] = {1};
}

// ignored test case (may have uncompiled code in body)
_test1(testE, fixtureA)
{
    int uncompiledCode[0] = {1};
}

// ignored test case (may have uncompiled code in body)
_test2(testF, fixtureA, fixtureB)
{
    int uncompiledCode[0] = {1};
}

\end{lstlisting}

%---------------------------------------------------------------------
\subsubsection{Assert-ы}

\begin{itemize}
\item Для проверки логических выражений:
    \begin{enumerate}[]
    \item isTrue(actual)
    \item isFalse(actual)
    \end{enumerate}
\item Для проверки на (не)равенство целых типов:
    \begin{enumerate}[]
    \item areEq(expected, actual)
    \item areNotEq(expected, actual)
    \end{enumerate}
\item Для проверки на (не)равенство вещественных типов:
    \begin{enumerate}[]
    \item areDoubleEq(expected, actual, delta)
    \item areDoubleNotEq(expected, actual, delta)
    \end{enumerate}
\item Для проверки вызова исключений тестируемым кодом:
    \begin{enumerate}[]
    \item willThrow(expression, exceptionType)
    \item noSpecificThrow(expression, exceptionType)
    \item noAnyCppThrow(expression)
    \item noSehThrow(expression)
    \end{enumerate}
\end{itemize}

\clearpage
%-----------------------------------------------------------------------------------------
\subsection{Lua Test Engine}

%---------------------------------------------------------------------
\subsubsection{Тесты}
\label{sec:lua_test_syntax}

\begin{lstlisting}[language=lua]
local qq = 
{
    initialize = function() end;
    release = function() end;
    add = 
        function(self, value)
            table.insert(self.list, value)
            if self.list[#self.list] then
                return true
            end
        end;
    list = {};
};

sampleFixture = 
{
    setUp = function()
        qq:initialize()
    end
    ;
    tearDown = function()
        qq:release()
    end
    ;
};

function simpleTest()
    local q = 2
    areEq(4, q + 2)
end

-- sampleFixture:setUp() will be executed BEFORE 'addTest'
-- sampleFixture:tearDown() will be executed AFTER 'addTest'
function sampleFixture.addTest()
    isTrue(qq:add(""))
end
\end{lstlisting}

%---------------------------------------------------------------------
\subsubsection{Assert-ы}

\begin{itemize}
\item Для проверки логических выражений:
    \begin{enumerate}[]
    \item isTrue(actual)
    \item isFalse(actual)
    \end{enumerate}
\item Для проверки на (не)равенство чисел:
    \begin{enumerate}[]
    \item areEq(expected, actual)
    \item areNotEq(expected, actual)
    \end{enumerate}
\item Для проверки успеха/краха
    \begin{enumerate}[]
    \item noThrow(functionForRun, \ldots)
    \item willThrow(functionForRun, \ldots)
    \end{enumerate}
\item Для проверки соответствия типу:
    \begin{enumerate}[]
    \item isFunction(actual)
    \item isTable(actual)
    \item isNumber(actual)
    \item isString(actual)
    \item isBoolean(actual)
    \item isBoolean(actual)
    \item isNil(actual)
    \end{enumerate}
\item Для проверки несоответствия типу:
    \begin{enumerate}[]
    \item isNotFunction(actual)
    \item isNotTable(actual)
    \item isNotNumber(actual)
    \item isNotString(actual)
    \item isNotBoolean(actual)
    \item isNotBoolean(actual)
    \item isNotNil(actual)
    \end{enumerate}
\end{itemize}

%-----------------------------------------------------------------------------------------
% \subsection{Процесс разработки}

%-----------------------------------------------------------------------------------------
% \subsection{Создание тестового модуля в Visual Studio 2010}

%-----------------------------------------------------------------------------------------
\subsection{Запуск тестов}

Для запуска тестов одного тестового контейнера можно использовать отдельный модуль \path{default_test_run.lua}. Командная строка запуска будет выглядеть примерно так:
\begin{verbatim}
lua5.1.exe  -l load_scite_listener -l testunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

Вместо непосредственного указания пути к файлу контейнера (TEST~\_CONTAINER~\_PATH) можно указывать:
\begin{itemize}
\item SciTE: \verb`$(FileNameExt)`
\item Visual Studio 2010: \verb`$(TargetPath)`
\end{itemize}

В качестве скрипта загрузки TestListner можно указывать:
\begin{itemize}
\item SciTE: \verb`-l load_vc_listener`
\item Visual Studio 2010: \verb`-l load_scite_listener`
\end{itemize}

Указывать \verb`TEST_CONTAINER_PATH` в двойных квадратных скобках необходимо, чтобы корректно обработать в пути обратные слэши (backslash).
Если \testunit\ установлен в нестандартной папке и приложение-интерпретатор не может самостоятельно найти этот модуль, придется добавить в командную строку перед ключом \verb`-l` дополнительный код:
\begin{verbatim}
lua5.1.exe 
-e "package.path=[[PATH_TO_TESTUNIT/?.lua]]..package.path"
-l testunit.default_test_run -e "run([[TEST_CONTAINER_PATH]])"
\end{verbatim}

В SciTE составленную командную строку можно задать, например, в настройках пользователя, прописав:
\begin{verbatim}
command.go.*.t.lua=lua5.1.exe -l load_scite_listener -l default_test_run -e "run([[$(FileNameExt)]])"
\end{verbatim}

В Visual Studio 2010 нужно добавить ее в настройки проектника, например:
\begin{itemize}
\item Debugging $to$ Command = \path{lua5.1.exe}
\item Debugging $to$ Command Arguments = \verb`-l load_vc_listener -l default_test_run -e "[[$(TargetPath)]]"`
\item Build Events $to$ Post-Build Event $to$ Command Line = \verb`lua5.1.exe -l load_vc_listener -l default_test_run -e "[[$(TargetPath)]]"`
\item Build Events $to$ Post-Build Event $to$ Description = Run unit tests \ldots
\end{itemize}

%%-------------------------------------------------------------------------
% \subsection{Разработка компонента}

% Открываем компонент (для C++ -- это файлы \path{*.h}, \path{*.cpp} и \path{*.t.cpp}) в IDE (или подходящего редактора, который <<обвешан>> скриптами для работы с модульными тестами\footnote{Не ждите пока любимый только Вами, но не используемый другими разработчиками редактор будет соответствующим образом <<накачан>> скриптами, сделайте это сами. Список того, что будет поддерживаться однозначно -- это MS Visual Studio и SciTE.}). Подразумевается, что все используемые текущим компоненты уже протестированы.

% Выбираем для проекта конфигурацию <<test>>. Результатом сборки будет тестовый драйвер (Test Driver). При помощи него становиться возможным запуск содержащихся в нем тестов. Но поскольку мы вносим изменения в один компонент, то будет достаточным прогон только тестов, относящихся к нему.

% Намечаем изменения, которые необходимо внести в компонент. Пишем в файле тестов (\path{*.t.cpp} -- для C++) новые тесты, проверяющие поведение кода согласно последней спецификации, либо подправляем уже имеющиеся. Затем производим сборку проекта и запуск тестов, для удобства эти два действия должны выполняться вспомогательным скриптом в одну атомарную операцию. Убеждаемся, что новые тесты провалились\footnote{А то вдруг и делать-то уже ничего не надо и код уже отвечает спецификации :-) }. Вносим изменения в основной код, опять запускаем тесты, смотрим какие из них завершились с ошибкой, исправляем код, опять прогоняем тесты и так до тех пор пока не будут проходить все тесты. 

%%-------------------------------------------------------------------------
% \subsection{Сдача кода в центральный репозиторий}

% Если делаете доставку пакета, то прогоните перед этим все его модульные тесты, если группу пакетов -- тесты всех пакетов, входящих в эту группу.

%%-------------------------------------------------------------------------
% \subsection{<<Night Build>>}

% На сервере автоматически выполняется сборка и модульное тестирование значительного количества компонентов (например, всех), находящихся в хранилище исходного кода. И потом с утречка программисты будут <<радоваться>>, читая списки завалившихся ночью тестов. 

% Можно подобную операцию выполнять дважды в сутки -- в обед и собственно ночью. А в качестве наказания за проваленную сборку можно назначать виновного отвечать за подобные полные сборки до тех пор, пока кто-нибудь еще не облажается.

%%-------------------------------------------------------------------------------------------------------------
% \section{Рекомендуемая литература}
